================================================================
Repopack Output File
================================================================

This file was generated by Repopack on: 2024-08-12T22:10:23.829Z

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This header section
2. Repository structure
3. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
1. This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
2. When processing this file, use the separators and "File:" markers to
  distinguish between different files in the repository.
3. Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.



For more information about Repopack, visit: https://github.com/yamadashy/repopack

================================================================
Repository Structure
================================================================
functions/
  .gitignore
  index.js
  package.json
public/
  404.html
  index.html
  manifest.json
  robots.txt
src/
  components/
    BottomNav.js
    DriverAvailability.js
    ForgotPasswordForm.js
    Header.js
    Layout.js
    Login.js
    Logo.js
    Navbar.js
    Notifications.js
    OfferRide.js
    PrivateRoute.js
    Profile.js
    PushNotifications.js
    RequestRide.js
    RideHistory.js
    Sidebar.js
    Signup.js
    SimpleForm.js
  contexts/
    AuthContext.js
    NotificationsContext.js
  pages/
    AuthPage.js
    DemoPage.js
    ForgotPassword.js
    Home.js
    Login.js
    OfferRide.js
    Profile.js
    RequestRide.js
    RideHistory.js
    Signup.js
  utils/
    aiMatching.js
    formValidation.js
    rideMatching.js
  App.css
  App.js
  AppContent.js
  firebase.js
  index.css
  index.js
  logo.svg
  reportWebVitals.js
  theme.js
.firebaserc
.gitignore
claude_old_firebase.txt
domain_setup.md
firebase.json
firestore.indexes.json
firestore.rules
package.json
README.md

================================================================
Repository Files
================================================================

================
File: functions/.gitignore
================
node_modules/
*.local

================
File: functions/index.js
================
const functions = require('firebase-functions');
const admin = require('firebase-admin');
admin.initializeApp();
const { runMatchingOnNewEntry } = require('./rideMatching');
exports.sendPushNotification = functions.db

  .document('rides/{rideId}')
  .onUpdate(async (change, context) => {
    const newValue = change.after.data();
    const previousValue = change.before.data();

    // Check if the status has changed
    if (newValue.status !== previousValue.status) {
      const rideId = context.params.rideId;

      // Get the user IDs for both the rider and the driver
      const riderId = newValue.riderId;
      const driverId = newValue.driverId;

      // Get the FCM tokens for both users
      const riderDoc = await admin.db
        ().collection('users').doc(riderId).get();
      const driverDoc = await admin.db
        ().collection('users').doc(driverId).get();

      const riderToken = riderDoc.data().fcmToken;
      const driverToken = driverDoc.data().fcmToken;

      if (riderToken) {
        const message = {
          token: riderToken,
          notification: {
            title: 'Ride Status Update',
            body: `Your ride (ID: ${rideId}) status has changed to ${newValue.status}.`
          },
          data: {
            rideId: rideId,
            status: newValue.status
          }
        };
        await admin.messaging().send(message);
      }

      if (driverToken) {
        const message = {
          token: driverToken,
          notification: {
            title: 'Ride Status Update',
            body: `Your ride (ID: ${rideId}) status has changed to ${newValue.status}.`
          },
          data: {
            rideId: rideId,
            status: newValue.status
          }
        };
        await admin.messaging().send(message);
      }
    }
  });
exports.triggerRideMatching = functions.firestore
  .document('rideRequests/{requestId}')
  .onCreate(async (snap, context) => {
    // Run ride matching when a new ride request is created
    await runMatchingOnNewEntry();
  });

exports.triggerRideMatchingOnOffer = functions.firestore
  .document('driverAvailability/{offerId}')
  .onCreate(async (snap, context) => {
    // Run ride matching when a new driver availability is created
    await runMatchingOnNewEntry();
  });

================
File: functions/package.json
================
{
  "name": "functions",
  "description": "Cloud Functions for Firebase",
  "scripts": {
    "lint": "",
    "serve": "firebase emulators:start --only functions",
    "shell": "firebase functions:shell",
    "start": "npm run shell",
    "deploy": "firebase deploy --only functions",
    "logs": "firebase functions:log"
  },
  "engines": {
    "node": "18"
  },
  "main": "index.js",
  "dependencies": {
    "firebase-admin": "^12.1.0",
    "firebase-functions": "^5.0.0"
  },
  "devDependencies": {
    "firebase-functions-test": "^3.1.0"
  },
  "private": true
}

================
File: public/404.html
================
<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Page Not Found</title>

    <style media="screen">
      body { background: #ECEFF1; color: rgba(0,0,0,0.87); font-family: Roboto, Helvetica, Arial, sans-serif; margin: 0; padding: 0; }
      #message { background: white; max-width: 360px; margin: 100px auto 16px; padding: 32px 24px 16px; border-radius: 3px; }
      #message h3 { color: #888; font-weight: normal; font-size: 16px; margin: 16px 0 12px; }
      #message h2 { color: #ffa100; font-weight: bold; font-size: 16px; margin: 0 0 8px; }
      #message h1 { font-size: 22px; font-weight: 300; color: rgba(0,0,0,0.6); margin: 0 0 16px;}
      #message p { line-height: 140%; margin: 16px 0 24px; font-size: 14px; }
      #message a { display: block; text-align: center; background: #039be5; text-transform: uppercase; text-decoration: none; color: white; padding: 16px; border-radius: 4px; }
      #message, #message a { box-shadow: 0 1px 3px rgba(0,0,0,0.12), 0 1px 2px rgba(0,0,0,0.24); }
      #load { color: rgba(0,0,0,0.4); text-align: center; font-size: 13px; }
      @media (max-width: 600px) {
        body, #message { margin-top: 0; background: white; box-shadow: none; }
        body { border-top: 16px solid #ffa100; }
      }
    </style>
  </head>
  <body>
    <div id="message">
      <h2>404</h2>
      <h1>Page Not Found</h1>
      <p>The specified file was not found on this website. Please check the URL for mistakes and try again.</p>
      <h3>Why am I seeing this?</h3>
      <p>This page was generated by the Firebase Command-Line Interface. To modify it, edit the <code>404.html</code> file in your project's configured <code>public</code> directory.</p>
    </div>
  </body>
</html>

================
File: public/index.html
================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <link rel="icon" href="%PUBLIC_URL%/favicon.ico" />
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@400;500;600;700&display=swap" rel="stylesheet">
    <meta name="theme-color" content="#000000" />
    <meta
      name="description"
      content="Making carpooling convinent and eco-friendly for schools"
    />
    <link rel="apple-touch-icon" href="%PUBLIC_URL%/logo192.png" />
    <!--
      manifest.json provides metadata used when your web app is installed on a
      user's mobile device or desktop. See https://developers.google.com/web/fundamentals/web-app-manifest/
    -->
    <link rel="manifest" href="%PUBLIC_URL%/manifest.json" />
    <!--
      Notice the use of %PUBLIC_URL% in the tags above.
      It will be replaced with the URL of the `public` folder during the build.
      Only files inside the `public` folder can be referenced from the HTML.

      Unlike "/favicon.ico" or "favicon.ico", "%PUBLIC_URL%/favicon.ico" will
      work correctly both with client-side routing and a non-root public URL.
      Learn how to configure a non-root public URL by running `npm run build`.
    -->
    <title>Zwisch | Gemini-Powered Carpooling</title>
  </head>
  <body>
    <noscript>You need to enable JavaScript to run this app.</noscript>
    <div id="root"></div>
    <!--
      This HTML file is a template.
      If you open it directly in the browser, you will see an empty page.

      You can add webfonts, meta tags, or analytics to this file.
      The build step will place the bundled scripts into the <body> tag.

      To begin the development, run `npm start` or `yarn start`.
      To create a production bundle, use `npm run build` or `yarn build`.
    -->
  </body>
</html>

================
File: public/manifest.json
================
{
  "short_name": "React App",
  "name": "Create React App Sample",
  "icons": [
    {
      "src": "favicon.ico",
      "sizes": "64x64 32x32 24x24 16x16",
      "type": "image/x-icon"
    },
    {
      "src": "logo192.png",
      "type": "image/png",
      "sizes": "192x192"
    },
    {
      "src": "logo512.png",
      "type": "image/png",
      "sizes": "512x512"
    }
  ],
  "start_url": ".",
  "display": "standalone",
  "theme_color": "#000000",
  "background_color": "#ffffff"
}

================
File: public/robots.txt
================
# https://www.robotstxt.org/robotstxt.html
User-agent: *
Disallow:

================
File: src/components/BottomNav.js
================
import React, { useState } from 'react';
import { BottomNavigation, BottomNavigationAction, Paper } from '@mui/material';
import DirectionsCarIcon from '@mui/icons-material/DirectionsCar';
import PersonIcon from '@mui/icons-material/Person';
import HistoryIcon from '@mui/icons-material/History';
import AccountCircleIcon from '@mui/icons-material/AccountCircle';

const BottomNav = () => {
  const [value, setValue] = useState(0);

  return (
    <Paper sx={{ position: 'fixed', bottom: 0, left: 0, right: 0 }} elevation={3}>
      <BottomNavigation
        showLabels
        value={value}
        onChange={(event, newValue) => {
          setValue(newValue);
        }}
        sx={{
          '& .MuiBottomNavigationAction-root': {
            color: '#999',
            '&.Mui-selected': {
              color: '#58F5BB',
            },
          },
        }}
      >
        <BottomNavigationAction label="Rides" icon={<DirectionsCarIcon />} />
        <BottomNavigationAction label="Driver" icon={<PersonIcon />} />
        <BottomNavigationAction label="History" icon={<HistoryIcon />} />
        <BottomNavigationAction label="Profile" icon={<AccountCircleIcon />} />
      </BottomNavigation>
    </Paper>
  );
};

export default BottomNav;

================
File: src/components/DriverAvailability.js
================
import React, { useState, useContext } from 'react';
import { TextField, Button, Typography, Container, CircularProgress } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db } from '../firebase';
import { matchRideOffer } from '../utils/aiMatching';
import { collection, addDoc } from 'firebase/firestore';

const DriverAvailability = () => {
  const [availability, setAvailability] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);
  const { currentUser } = useContext(AuthContext);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setSuccess(false);

    try {
      // Process the availability using AI
      const processedAvailability = await matchRideOffer(availability);

      // Save the driver availability to db

      await addDoc(collection(db, 'driverAvailability'), {
        userId: currentUser.uid,
        rawAvailability: availability,
        processedAvailability,
        status: 'active',
        createdAt: new Date(),
      });

      setSuccess(true);
      setAvailability('');
    } catch (error) {
      console.error('Error processing driver availability:', error);
      setError('Failed to process driver availability. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Typography variant="h4" gutterBottom>
        Set Your Availability
      </Typography>
      {error && (
        <Typography color="error" gutterBottom>
          {error}
        </Typography>
      )}
      {success && (
        <Typography color="success" gutterBottom>
          Availability successfully set!
        </Typography>
      )}
      <form onSubmit={handleSubmit}>
        <TextField
          fullWidth
          label="Describe your availability"
          multiline
          rows={4}
          value={availability}
          onChange={(e) => setAvailability(e.target.value)}
          margin="normal"
          placeholder="E.g., Available for morning rides on weekdays from 7 AM to 9 AM, prefer pickups in downtown area"
          disabled={loading}
        />
        <Button
          type="submit"
          variant="contained"
          color="primary"
          disabled={loading}
          sx={{ mt: 2 }}
        >
          {loading ? <CircularProgress size={24} /> : 'Set Availability'}
        </Button>
      </form>
    </Container>
  );
};

export default DriverAvailability;

================
File: src/components/ForgotPasswordForm.js
================
import React, { useState } from 'react';
import { TextField, Button, Typography, Container, Box } from '@mui/material';
import { auth } from '../firebase';
import Logo from './Logo';

const ForgotPasswordForm = () => {
  const [email, setEmail] = useState('');
  const [message, setMessage] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);

  const handleResetPassword = async (e) => {
    e.preventDefault();
    setLoading(true);
    setMessage('');
    setError('');

    try {
      await auth.sendPasswordResetEmail(email);
      setMessage('Check your email for further instructions');
    } catch (error) {
      setError('Failed to reset password. ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box
      sx={{
        backgroundColor: '#58F5BB',
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
      }}
    >
      <Container maxWidth="xs">
        <Box
          sx={{
            backgroundColor: 'white',
            padding: 4,
            borderRadius: 2,
            boxShadow: 3,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Logo variant="default" width={150} />
          <Typography variant="h5" align="center" gutterBottom sx={{ mt: 2 }}>
            Reset Your Password
          </Typography>
          {error && (
            <Typography color="error" align="center">
              {error}
            </Typography>
          )}
          {message && (
            <Typography color="primary" align="center">
              {message}
            </Typography>
          )}
          <form onSubmit={handleResetPassword} style={{ width: '100%', marginTop: '1rem' }}>
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              autoFocus
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              color="primary"
              disabled={loading}
              sx={{ mt: 3, mb: 2 }}
            >
              {loading ? 'Sending...' : 'Reset Password'}
            </Button>
          </form>
        </Box>
      </Container>
    </Box>
  );
};

export default ForgotPasswordForm;

================
File: src/components/Header.js
================
import React, { useContext } from 'react';
import { AppBar, Toolbar, Box, Typography, Avatar, IconButton } from '@mui/material';
import { styled } from '@mui/system';
import MenuIcon from '@mui/icons-material/Menu';
import Notifications from './Notifications';
import { AuthContext } from '../contexts/AuthContext';

const ProfileBox = styled(Box)(({ theme }) => ({
  display: 'flex',
  alignItems: 'center',
  padding: theme.spacing(0.5, 1),
  borderRadius: 20,
  border: `1px solid ${theme.palette.divider}`,
  cursor: 'pointer',
}));

const Header = ({ onProfileClick }) => {
  const { currentUser } = useContext(AuthContext);

  return (
    <AppBar position="static" sx={{ backgroundColor: '#58F5BB', boxShadow: 'none' }}>
      <Toolbar sx={{ justifyContent: 'space-between' }}>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <IconButton edge="start" color="inherit" aria-label="menu">
            <MenuIcon />
          </IconButton>
        </Box>
        <Typography variant="h6" component="div" sx={{ flexGrow: 1, textAlign: 'center' }}>
          Zwisch
        </Typography>
        <Box sx={{ display: 'flex', alignItems: 'center' }}>
          <Notifications />
          <ProfileBox onClick={onProfileClick}>
            <Avatar src={currentUser?.photoURL} alt={currentUser?.displayName} sx={{ width: 32, height: 32, mr: 1 }} />
            <Box>
              <Typography variant="subtitle2">{currentUser?.displayName}</Typography>
              <Typography variant="caption">{currentUser?.email}</Typography>
            </Box>
          </ProfileBox>
        </Box>
      </Toolbar>
    </AppBar>
  );
};

export default Header;

================
File: src/components/Layout.js
================
import React, { useState } from 'react';
import { Outlet } from 'react-router-dom';
import { Box, Drawer, AppBar, Toolbar, IconButton, Typography } from '@mui/material';
import MenuIcon from '@mui/icons-material/Menu';
import Sidebar from './Sidebar';
import Navbar from './Navbar';
import { useNotifications } from '../contexts/NotificationsContext';

const drawerWidth = 240;

const Layout = ({ darkMode, toggleDarkMode }) => {
  const [mobileOpen, setMobileOpen] = useState(false);
  const { notifications } = useNotifications();

  const handleDrawerToggle = () => {
    setMobileOpen(!mobileOpen);
  };

  return (
    <Box sx={{ display: 'flex' }}>
      <AppBar
        position="fixed"
        sx={{
          width: { sm: `calc(100% - ${drawerWidth}px)` },
          ml: { sm: `${drawerWidth}px` },
        }}
      >
        <Toolbar>
          <IconButton
            color="inherit"
            aria-label="open drawer"
            edge="start"
            onClick={handleDrawerToggle}
            sx={{ mr: 2, display: { sm: 'none' } }}
          >
            <MenuIcon />
          </IconButton>
          <Typography variant="h6" noWrap component="div" sx={{ flexGrow: 1 }}>
            Zwisch
          </Typography>
          <Navbar darkMode={darkMode} toggleDarkMode={toggleDarkMode} notifications={notifications} />
        </Toolbar>
      </AppBar>
      <Box
        component="nav"
        sx={{ width: { sm: drawerWidth }, flexShrink: { sm: 0 } }}
      >
        <Drawer
          variant="temporary"
          open={mobileOpen}
          onClose={handleDrawerToggle}
          ModalProps={{
            keepMounted: true, // Better open performance on mobile.
          }}
          sx={{
            display: { xs: 'block', sm: 'none' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
        >
          <Sidebar />
        </Drawer>
        <Drawer
          variant="permanent"
          sx={{
            display: { xs: 'none', sm: 'block' },
            '& .MuiDrawer-paper': { boxSizing: 'border-box', width: drawerWidth },
          }}
          open
        >
          <Sidebar />
        </Drawer>
      </Box>
      <Box
        component="main"
        sx={{
          flexGrow: 1,
          p: 3,
          width: { sm: `calc(100% - ${drawerWidth}px)` },
          ml: { sm: `${drawerWidth}px` },
          mt: ['56px', '64px'],
          display: 'flex',
          justifyContent: 'center', // Center content horizontally
          alignItems: 'flex-start', // Align content to the top
        }}
      >
        <Box maxWidth="lg" width="100%">
          <Outlet />
        </Box>
      </Box>
    </Box>
  );
};

export default Layout;

================
File: src/components/Login.js
================
import React, { useState } from 'react';
import { TextField, Button, Typography, Container, Box, Link } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { auth } from '../firebase';
import Logo from './Logo';

const Login = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();

  const handleLogin = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    try {
      await auth.signInWithEmailAndPassword(email, password);
      navigate('/');
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Box
      sx={{
        backgroundColor: '#58F5BB',
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
      }}
    >
      <Container maxWidth="xs">
        <Box
          sx={{
            backgroundColor: 'white',
            padding: 4,
            borderRadius: 2,
            boxShadow: 3,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Logo variant="default" width={150} />
          <Typography variant="h5" align="center" gutterBottom sx={{ mt: 2 }}>
            Sign in to your Zwisch account
          </Typography>
          {error && (
            <Typography color="error" align="center">
              {error}
            </Typography>
          )}
          <form onSubmit={handleLogin} style={{ width: '100%', marginTop: '1rem' }}>
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              id="email"
              label="Email Address"
              name="email"
              autoComplete="email"
              autoFocus
              value={email}
              onChange={(e) => setEmail(e.target.value)}
            />
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type="password"
              id="password"
              autoComplete="current-password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
            />
            <Button
              type="submit"
              fullWidth
              variant="contained"
              color="primary"
              disabled={loading}
              sx={{ mt: 3, mb: 2 }}
            >
              {loading ? 'Signing In...' : 'Sign In'}
            </Button>
          </form>
          <Box sx={{ mt: 2, display: 'flex', justifyContent: 'space-between', width: '100%' }}>
            <Link href="/forgot-password" variant="body2">
              Forgot password?
            </Link>
            <Link href="/signup" variant="body2">
              Don't have an account? Sign Up
            </Link>
          </Box>
        </Box>
      </Container>
    </Box>
  );
};

export default Login;

================
File: src/components/Logo.js
================
import React from 'react';
import { Box } from '@mui/material';

const Logo = ({ variant = 'default', width = 150 }) => {
  const logoSrc = variant === 'splash' ? '/splash_screen.png' : '/full_logo.png';

  return (
    <Box
      component="img"
      src={logoSrc}
      alt="Zwisch Logo"
      sx={{
        width: width,
        height: 'auto',
        objectFit: 'contain',
      }}
    />
  );
};

export default Logo;

================
File: src/components/Navbar.js
================
import React from 'react';
import { IconButton, Badge } from '@mui/material';
import { Notifications, Brightness4, Brightness7 } from '@mui/icons-material';

const Navbar = ({ darkMode, toggleDarkMode, notifications }) => {
  return (
    <>
      <IconButton color="inherit" onClick={toggleDarkMode}>
        {darkMode ? <Brightness7 /> : <Brightness4 />}
      </IconButton>
      <IconButton color="inherit">
        <Badge badgeContent={notifications.length} color="secondary">
          <Notifications />
        </Badge>
      </IconButton>
    </>
  );
};

export default Navbar;

================
File: src/components/Notifications.js
================
import React, { useContext } from 'react';
import { Badge, Menu, MenuItem, IconButton, Typography } from '@mui/material';
import NotificationsIcon from '@mui/icons-material/Notifications';
import { NotificationsContext } from '../contexts/NotificationsContext';

const Notifications = () => {
  const { notifications, markAsRead } = useContext(NotificationsContext);
  const [anchorEl, setAnchorEl] = React.useState(null);

  const handleClick = (event) => {
    setAnchorEl(event.currentTarget);
  };

  const handleClose = () => {
    setAnchorEl(null);
  };

  const handleNotificationClick = (notificationId) => {
    markAsRead(notificationId);
    handleClose();
  };

  return (
    <>
      <IconButton color="inherit" onClick={handleClick}>
        <Badge badgeContent={notifications.length} color="secondary">
          <NotificationsIcon />
        </Badge>
      </IconButton>
      <Menu
        anchorEl={anchorEl}
        keepMounted
        open={Boolean(anchorEl)}
        onClose={handleClose}
      >
        {notifications.length === 0 ? (
          <MenuItem>No new notifications</MenuItem>
        ) : (
          notifications.map((notification) => (
            <MenuItem
              key={notification.id}
              onClick={() => handleNotificationClick(notification.id)}
            >
              <Typography variant="body2">{notification.message}</Typography>
            </MenuItem>
          ))
        )}
      </Menu>
    </>
  );
};

export default Notifications;

================
File: src/components/OfferRide.js
================
import React, { useState, useContext } from 'react';
import { TextField, Button, Typography, Container, CircularProgress } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db } from '../firebase';
import { matchRideOffer } from '../utils/aiMatching';
import { collection, addDoc, query, where, getDocs } from 'firebase/firestore';

const OfferRide = () => {
  const [offer, setOffer] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [success, setSuccess] = useState(false);
  const { currentUser } = useContext(AuthContext);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');
    setSuccess(false);

    try {
      // Process the offer using AI
      const processedOffer = await matchRideOffer(offer);

      // Save the driver availability to db
      await addDoc(collection(db, 'driverAvailability'), {
        userId: currentUser.uid,
        userEmail: currentUser.email,
        rawOffer: offer,
        processedOffer,
        status: 'active',
        createdAt: new Date(),
      });

      setSuccess(true);
      setOffer('');
    } catch (error) {
      console.error('Error processing driver availability:', error);
      setError('Failed to process driver availability. Please try again.');
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Typography variant="h4" gutterBottom>
        Offer a Ride
      </Typography>
      {error && (
        <Typography color="error" gutterBottom>
          {error}
        </Typography>
      )}
      {success && (
        <Typography color="success" gutterBottom>
          Ride offer successfully submitted!
        </Typography>
      )}
      <form onSubmit={handleSubmit}>
        <TextField
          fullWidth
          label="Describe your ride offer"
          multiline
          rows={4}
          value={offer}
          onChange={(e) => setOffer(e.target.value)}
          margin="normal"
          placeholder="E.g., Available for morning rides on weekdays from 7 AM to 9 AM, prefer pickups in downtown area"
          disabled={loading}
        />
        <Button
          type="submit"
          variant="contained"
          color="primary"
          disabled={loading}
          sx={{ mt: 2 }}
        >
          {loading ? <CircularProgress size={24} /> : 'Submit Offer'}
        </Button>
      </form>
    </Container>
  );
};

export default OfferRide;

================
File: src/components/PrivateRoute.js
================
import React, { useContext } from 'react';
import { Navigate, Outlet } from 'react-router-dom';
import { AuthContext } from '../contexts/AuthContext';

const PrivateRoute = () => {
  const { currentUser } = useContext(AuthContext);

  return currentUser ? <Outlet /> : <Navigate to="/login" />;
};

export default PrivateRoute;

================
File: src/components/Profile.js
================
import React, { useState, useEffect, useContext } from 'react';
import { Container, Typography, TextField, Button, Grid, CircularProgress } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db, auth } from '../firebase';
import { doc, getDoc, updateDoc } from 'firebase/firestore';
import { useNavigate } from 'react-router-dom';

const Profile = () => {
  const { currentUser } = useContext(AuthContext);
  const [profile, setProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchProfile = async () => {
      try {
        const profileDoc = await getDoc(doc(db, 'users', currentUser.uid));
        setProfile(profileDoc.data());
      } catch (error) {
        console.error('Error fetching profile:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchProfile();
  }, [currentUser]);

  const handleChange = (e) => {
    setProfile({ ...profile, [e.target.name]: e.target.value });
  };

  const handleSave = async () => {
    setSaving(true);
    try {
      await updateDoc(doc(db, 'users', currentUser.uid), profile);
      alert('Profile updated successfully!');
    } catch (error) {
      console.error('Error updating profile:', error);
      alert('Failed to update profile. Please try again.');
    } finally {
      setSaving(false);
    }
  };

  const handleLogout = async () => {
    try {
      await auth.signOut();
      navigate('/auth');
    } catch (error) {
      console.error('Error signing out:', error);
    }
  };

  if (loading) {
    return <CircularProgress />;
  }

  return (
    <Container maxWidth="sm">
      <Typography variant="h4" gutterBottom>
        User Profile
      </Typography>
      <Grid container spacing={2}>
        <Grid item xs={12}>
          <TextField
            fullWidth
            label="Name"
            name="name"
            value={profile?.name || ''}
            onChange={handleChange}
            margin="normal"
          />
        </Grid>
        <Grid item xs={12}>
          <TextField
            fullWidth
            label="Email"
            name="email"
            value={profile?.email || ''}
            disabled
            margin="normal"
          />
        </Grid>
        <Grid item xs={12}>
          <TextField
            fullWidth
            label="Role"
            name="role"
            value={profile?.role || ''}
            disabled
            margin="normal"
          />
        </Grid>
        <Grid item xs={12}>
          <Button
            variant="contained"
            color="primary"
            onClick={handleSave}
            disabled={saving}
          >
            {saving ? 'Saving...' : 'Save Changes'}
          </Button>
        </Grid>
        <Grid item xs={12}>
          <Button
            variant="outlined"
            color="secondary"
            onClick={handleLogout}
          >
            Logout
          </Button>
        </Grid>
      </Grid>
    </Container>
  );
};

export default Profile;

================
File: src/components/PushNotifications.js
================
import React, { useState, useEffect, useContext } from 'react';
import { Snackbar, IconButton } from '@mui/material';
import CloseIcon from '@mui/icons-material/Close';
import { requestNotificationPermission, onMessageListener } from '../firebase';
import { AuthContext } from '../contexts/AuthContext';

const PushNotifications = () => {
  const [notification, setNotification] = useState({ title: '', body: '' });
  const [open, setOpen] = useState(false);
  const { currentUser } = useContext(AuthContext);

  useEffect(() => {
    if (currentUser) {
      requestNotificationPermission(currentUser.uid).catch(console.error);
    }

    const unsubscribe = onMessageListener().then((payload) => {
      setNotification({ title: payload.notification.title, body: payload.notification.body });
      setOpen(true);
    }).catch(err => console.log('failed: ', err));

    return () => unsubscribe;
  }, [currentUser]);

  const handleClose = (event, reason) => {
    if (reason === 'clickaway') {
      return;
    }
    setOpen(false);
  };

  return (
    <Snackbar
      anchorOrigin={{
        vertical: 'top',
        horizontal: 'right',
      }}
      open={open}
      autoHideDuration={6000}
      onClose={handleClose}
      message={`${notification.title}: ${notification.body}`}
      action={
        <IconButton
          size="small"
          aria-label="close"
          color="inherit"
          onClick={handleClose}
        >
          <CloseIcon fontSize="small" />
        </IconButton>
      }
    />
  );
};

export default PushNotifications;

================
File: src/components/RequestRide.js
================
import React, { useState, useContext, useEffect } from 'react';
import { Container, Typography, TextField, Button, CircularProgress, Box, List, ListItem, ListItemText } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db } from '../firebase';
import { collection, addDoc, query, where, getDocs, orderBy } from 'firebase/firestore';
import { matchRideRequest } from '../utils/aiMatching';
import { performRideMatching } from '../utils/rideMatching';

const RequestRide = () => {
  const [request, setRequest] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [requests, setRequests] = useState([]);
  const { currentUser } = useContext(AuthContext);

  useEffect(() => {
    fetchRequests();
  }, [currentUser]);

  const fetchRequests = async () => {
    try {
      const q = query(
        collection(db, 'rideRequests'),
        where('userId', '==', currentUser.uid),
        orderBy('createdAt', 'desc')
      );
      const querySnapshot = await getDocs(q);
      const requestsData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setRequests(requestsData);
    } catch (error) {
      console.error('Error fetching ride requests:', error);
      setError('Failed to fetch ride requests. Please try again.');
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      console.log('Processing ride request...');
      const processedRequest = await matchRideRequest(request);
      console.log('Processed request:', processedRequest);

      console.log('Adding request to Firestore...');
      const docRef = await addDoc(collection(db, 'rideRequests'), {
        userId: currentUser.uid,
        userEmail: currentUser.email,
        rawRequest: request,
        processedRequest,
        status: 'pending',
        createdAt: new Date(),
      });
      console.log('Request added with ID:', docRef.id);

      console.log('Performing ride matching...');
      await performRideMatching();
      console.log('Ride matching completed');

      setRequest('');
      await fetchRequests();
      console.log('Requests fetched and updated');
    } catch (error) {
      console.error('Error submitting ride request:', error);
      setError(`Failed to submit ride request. Please try again. ${error.message}`);

      if (error.stack) {
        console.error('Error stack:', error.stack);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Typography variant="h4" gutterBottom>
        Request a Ride
      </Typography>
      {error && (
        <Typography color="error" gutterBottom>
          {error}
        </Typography>
      )}
      <form onSubmit={handleSubmit}>
        <TextField
          fullWidth
          label="Describe your ride request"
          multiline
          rows={4}
          value={request}
          onChange={(e) => setRequest(e.target.value)}
          margin="normal"
          placeholder="E.g., Need a ride to school tomorrow morning from 123 Main St at 8 AM"
          disabled={loading}
        />
        <Button
          type="submit"
          variant="contained"
          color="primary"
          disabled={loading}
          sx={{ mt: 2 }}
        >
          {loading ? <CircularProgress size={24} /> : 'Submit Request'}
        </Button>
      </form>
      <Box mt={4}>
        <Typography variant="h6" gutterBottom>
          Your Ride Requests
        </Typography>
        <List>
          {requests.map((req) => (
            <ListItem key={req.id}>
              <ListItemText
                primary={req.rawRequest}
                secondary={`Status: ${req.status} | Created: ${new Date(req.createdAt.toDate()).toLocaleString()}`}
              />
            </ListItem>
          ))}
        </List>
      </Box>
    </Container>
  );
};

export default RequestRide;

================
File: src/components/RideHistory.js
================
import React, { useState, useEffect, useContext } from 'react';
import { Container, Typography, List, ListItem, ListItemText, Divider, CircularProgress } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db } from '../firebase';
import { collection, query, where, orderBy, limit, getDocs } from 'firebase/firestore';

const RideHistory = () => {
  const [rides, setRides] = useState([]);
  const [loading, setLoading] = useState(true);
  const { currentUser } = useContext(AuthContext);

  useEffect(() => {
    const fetchRides = async () => {
      try {
        const q = query(
          collection(db, 'rides'),
          where('userId', '==', currentUser.uid),
          orderBy('createdAt', 'desc'),
          limit(20)
        );
        const ridesSnapshot = await getDocs(q);

        const ridesData = ridesSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));

        setRides(ridesData);
      } catch (error) {
        console.error('Error fetching ride history:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchRides();
  }, [currentUser]);

  if (loading) {
    return <CircularProgress />;
  }

  return (
    <Container maxWidth="md">
      <Typography variant="h4" gutterBottom>
        Ride History
      </Typography>
      {rides.length === 0 ? (
        <Typography>No ride history found.</Typography>
      ) : (
        <List>
          {rides.map((ride, index) => (
            <React.Fragment key={ride.id}>
              <ListItem alignItems="flex-start">
                <ListItemText
                  primary={`${ride.pickup} to ${ride.destination}`}
                  secondary={
                    <>
                      <Typography component="span" variant="body2" color="text.primary">
                        Date: {new Date(ride.createdAt.toDate()).toLocaleDateString()}
                      </Typography>
                      {" — "}
                      {ride.status === 'completed' ? 'Completed' : 'Cancelled'}
                    </>
                  }
                />
              </ListItem>
              {index < rides.length - 1 && <Divider variant="inset" component="li" />}
            </React.Fragment>
          ))}
        </List>
      )}
    </Container>
  );
};

export default RideHistory;

================
File: src/components/Sidebar.js
================
import React, { useContext } from 'react';
import { Link, useLocation } from 'react-router-dom';
import { List, ListItem, ListItemIcon, ListItemText, Box, Divider, Typography } from '@mui/material';
import { Home, DirectionsCar, History, Person } from '@mui/icons-material';
import { AuthContext } from '../contexts/AuthContext';
import KeyIcon from '@mui/icons-material/Key';

const Sidebar = () => {
  const location = useLocation();
  const { currentUser } = useContext(AuthContext);

  const menuItems = [
    { text: 'Home', icon: <Home />, path: '/' },
    { text: 'Request Ride', icon: <DirectionsCar />, path: '/request-ride' },
    { text: 'Offer Ride', icon: <KeyIcon />, path: '/offer-ride' },
    { text: 'Ride History', icon: <History />, path: '/ride-history' },
  ];

  return (
    <Box sx={{ display: 'flex', flexDirection: 'column', height: '100%' }}>
      <List>
        {menuItems.map((item) => (
          <ListItem
            button
            key={item.text}
            component={Link}
            to={item.path}
            selected={location.pathname === item.path}
          >
            <ListItemIcon>{item.icon}</ListItemIcon>
            <ListItemText primary={item.text} />
          </ListItem>
        ))}
      </List>
      <Box sx={{ flexGrow: 1 }} />
      <Divider />
      <Box sx={{ p: 2 }}>
        <ListItem button component={Link} to="/profile">
          <ListItemIcon><Person /></ListItemIcon>
          <Box>
          <Typography variant='subtitle2'>Profile</Typography>
            {/*<Typography variant="subtitle2">{currentUser?.displayName}</Typography>*/}
            {/*<Typography variant="caption">{currentUser?.email}</Typography>*/}
          </Box>
        </ListItem>
      </Box>
    </Box>
  );
};

export default Sidebar;

================
File: src/components/Signup.js
================
import React, { useState } from 'react';
import { TextField, Button, Typography, Container, Box, Link, FormControlLabel, Radio, RadioGroup } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { signUp } from '../firebase';
import Logo from './Logo';
import { validateEmail, validateSchoolEmail, validatePassword, validateName, getEmailErrorMessage, getPasswordErrorMessage, getNameErrorMessage } from '../utils/formValidation';

const Signup = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [confirmPassword, setConfirmPassword] = useState('');
  const [name, setName] = useState('');
  const [userType, setUserType] = useState('student');
  const [childEmail, setChildEmail] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const navigate = useNavigate();

  const handleSignup = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    if (!validateForm()) {
      setLoading(false);
      return;
    }

    try {
      await signUp(email, password, name, userType, userType === 'parent' ? childEmail : null);
      navigate('/');
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  const validateForm = () => {
    if (!validateName(name)) {
      setError(getNameErrorMessage(name));
      return false;
    }
    if (!validateEmail(email) || !validateSchoolEmail(email)) {
      setError(getEmailErrorMessage(email));
      return false;
    }
    if (!validatePassword(password)) {
      setError(getPasswordErrorMessage(password));
      return false;
    }
    if (password !== confirmPassword) {
      setError("Passwords don't match");
      return false;
    }
    if (userType === 'parent' && (!validateEmail(childEmail) || !validateSchoolEmail(childEmail))) {
      setError(getEmailErrorMessage(childEmail));
      return false;
    }
    return true;
  };

  return (
    <Box
      sx={{
        backgroundColor: '#58F5BB',
        minHeight: '100vh',
        display: 'flex',
        alignItems: 'center',
        justifyContent: 'center',
      }}
    >
      <Container maxWidth="xs">
        <Box
          sx={{
            backgroundColor: 'white',
            padding: 4,
            borderRadius: 2,
            boxShadow: 3,
            display: 'flex',
            flexDirection: 'column',
            alignItems: 'center',
          }}
        >
          <Logo variant="default" width={150} />
          <Typography variant="h5" align="center" gutterBottom sx={{ mt: 2 }}>
            Create your Zwisch account
          </Typography>
          {error && (
            <Typography color="error" align="center">
              {error}
            </Typography>
          )}
          <form onSubmit={handleSignup} style={{ width: '100%', marginTop: '1rem' }}>
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              id="name"
              label="Full Name"
              name="name"
              autoComplete="name"
              autoFocus
              value={name}
              onChange={(e) => setName(e.target.value)}
              error={!!getNameErrorMessage(name)}
              helperText={getNameErrorMessage(name)}
            />
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              id="email"
              label="School Email Address"
              name="email"
              autoComplete="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              error={!!getEmailErrorMessage(email)}
              helperText={getEmailErrorMessage(email)}
            />
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              name="password"
              label="Password"
              type="password"
              id="password"
              autoComplete="new-password"
              value={password}
              onChange={(e) => setPassword(e.target.value)}
              error={!!getPasswordErrorMessage(password)}
              helperText={getPasswordErrorMessage(password)}
            />
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              name="confirmPassword"
              label="Confirm Password"
              type="password"
              id="confirmPassword"
              value={confirmPassword}
              onChange={(e) => setConfirmPassword(e.target.value)}
              error={password !== confirmPassword}
              helperText={password !== confirmPassword ? "Passwords don't match" : ""}
            />
            <RadioGroup
              aria-label="user-type"
              name="user-type"
              value={userType}
              onChange={(e) => setUserType(e.target.value)}
              sx={{ mt: 2 }}
            >
              <FormControlLabel value="student" control={<Radio />} label="I am a student" />
              <FormControlLabel value="parent" control={<Radio />} label="I am a parent" />
            </RadioGroup>
            {userType === 'parent' && (
              <TextField
                variant="outlined"
                margin="normal"
                required
                fullWidth
                id="childEmail"
                label="Child's School Email Address"
                name="childEmail"
                value={childEmail}
                onChange={(e) => setChildEmail(e.target.value)}
                error={!!getEmailErrorMessage(childEmail)}
                helperText={getEmailErrorMessage(childEmail)}
              />
            )}
            <Button
              type="submit"
              fullWidth
              variant="contained"
              color="primary"
              disabled={loading}
              sx={{ mt: 3, mb: 2 }}
            >
              {loading ? 'Signing Up...' : 'Sign Up'}
            </Button>
          </form>
          <Box sx={{ mt: 2 }}>
            <Link href="/login" variant="body2">
              Already have an account? Sign In
            </Link>
          </Box>
        </Box>
      </Container>
    </Box>
  );
};

export default Signup;

================
File: src/components/SimpleForm.js
================
import React, { useState } from 'react';
import { TextField, Button, Box, Typography } from '@mui/material';

const SimpleForm = () => {
  const [inputValue, setInputValue] = useState('[initialRequest]');
  const maxLength = 200;

  const handleChange = (e) => {
    if (e.target.value.length <= maxLength) {
      setInputValue(e.target.value);
    }
  };

  return (
    <Box sx={{ p: 2, display: 'flex', flexDirection: 'column', gap: 2 }}>
      <Typography variant="h5" component="h1" sx={{ fontWeight: 'bold' }}>
        Request a Ride
      </Typography>
      <Typography variant="body1" color="text.secondary" sx={{ mb: 2 }}>
        Talk about your ride's pickup & dropoff locations, schedules, and preferences like a specified driver.
      </Typography>
      <TextField
        fullWidth
        multiline
        rows={4}
        value={inputValue}
        onChange={handleChange}
        variant="outlined"
        sx={{
          '& .MuiOutlinedInput-root': {
            borderRadius: '16px',
            borderColor: '#58F5BB',
          },
        }}
      />
      <Box sx={{ display: 'flex', justifyContent: 'flex-end' }}>
        <Typography variant="caption" color="text.secondary">
          {inputValue.length}/{maxLength}
        </Typography>
      </Box>
      <Button
        variant="contained"
        color="primary"
        fullWidth
        sx={{
          borderRadius: '20px',
          textTransform: 'none',
          fontWeight: 'bold',
        }}
      >
        Submit Request
      </Button>
    </Box>
  );
};

export default SimpleForm;

================
File: src/contexts/AuthContext.js
================
import React, { createContext, useState, useEffect } from 'react';
import {
  auth, db
} from '../firebase';
import { doc, getDoc, setDoc } from 'firebase/firestore';

export const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [currentUser, setCurrentUser] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    const unsubscribe = auth.onAuthStateChanged(async (user) => {
      if (user) {
        const userDoc = await getDoc(doc(db, 'users', user.uid));
        if (userDoc.exists) {
          setCurrentUser({ ...user, ...userDoc.data() });
        } else {
          // If the user document doesn't exist, create it
          await setDoc(doc(db, 'users', user.uid), {
            email: user.email,
            name: user.displayName,
            createdAt: new Date(),
          });
          setCurrentUser(user);
        }
      } else {
        setCurrentUser(null);
      }
      setLoading(false);
    });

    return unsubscribe;
  }, []);

  const value = {
    currentUser,
    loading,
  };

  return (
    <AuthContext.Provider value={value}>
      {!loading && children}
    </AuthContext.Provider>
  );
};

================
File: src/contexts/NotificationsContext.js
================
import React, { createContext, useState, useEffect, useContext } from 'react';
import { db } from '../firebase';
import { AuthContext } from './AuthContext';
import { collection, query, where, onSnapshot, doc, updateDoc } from 'firebase/firestore';

export const NotificationsContext = createContext();

export const NotificationsProvider = ({ children }) => {
  const [notifications, setNotifications] = useState([]);
  const { currentUser } = useContext(AuthContext);

  useEffect(() => {
    if (currentUser) {
      const q = query(
        collection(db, 'notifications'),
        where('userId', '==', currentUser.uid),
        where('read', '==', false)
      );

      const unsubscribe = onSnapshot(q, (snapshot) => {
        const newNotifications = snapshot.docs.map((doc) => ({
          id: doc.id,
          ...doc.data(),
        }));
        setNotifications(newNotifications);
      });

      return () => unsubscribe();
    }
  }, [currentUser]);

  const markAsRead = async (notificationId) => {
    await updateDoc(doc(db, 'notifications', notificationId), {
      read: true,
    });
  };

  return (
    <NotificationsContext.Provider value={{ notifications, markAsRead }}>
      {children}
    </NotificationsContext.Provider>
  );
};

export const useNotifications = () => {
  const context = useContext(NotificationsContext);
  if (context === undefined) {
    throw new Error('useNotifications must be used within a NotificationsProvider');
  }
  return context;
};

================
File: src/pages/AuthPage.js
================
import React, { useState } from 'react';
import {
  Container,
  Box,
  Tabs,
  Tab,
  Typography,
  TextField,
  Button,
  Link,
  Paper,
  CircularProgress,
  Select,
  MenuItem,
  FormControl,
  InputLabel,
  useMediaQuery
} from '@mui/material';
import { styled, useTheme } from '@mui/system';
import { useNavigate } from 'react-router-dom';
import { signIn, signUp, checkUserExists } from '../firebase';
import Logo from '../components/Logo';
import { validateEmail, validatePassword, validateName, getEmailErrorMessage, getPasswordErrorMessage, getNameErrorMessage } from '../utils/formValidation';

const StyledPaper = styled(Paper)(({ theme }) => ({
  marginTop: theme.spacing(8),
  display: 'flex',
  flexDirection: 'column',
  alignItems: 'center',
  padding: theme.spacing(4),
  backgroundColor: theme.palette.background.paper,
  borderRadius: theme.shape.borderRadius,
  boxShadow: theme.shadows[5],
  [theme.breakpoints.down('sm')]: {
    marginTop: 0,
    height: '100vh',
    borderRadius: 0,
  },
}));

const Form = styled('form')(({ theme }) => ({
  width: '100%',
  marginTop: theme.spacing(1),
}));

const SubmitButton = styled(Button)(({ theme }) => ({
  margin: theme.spacing(3, 0, 2),
}));

const AuthPage = () => {
  const [tab, setTab] = useState(0);
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [userType, setUserType] = useState('student');
  const [childEmail, setChildEmail] = useState('');
  const [error, setError] = useState('');
  const [loading, setLoading] = useState(false);
  const [submitted, setSubmitted] = useState(false);
  const navigate = useNavigate();
  const theme = useTheme();
  const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

  const handleTabChange = (event, newValue) => {
    setTab(newValue);
    setError('');
    setSubmitted(false);
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setSubmitted(true);
    setLoading(true);
    setError('');

    try {
      if (tab === 0) {
        // Login
        if (!email || !password) {
          throw new Error('Please fill in all fields');
        }
        await signIn(email, password);
        navigate('/');
      } else {
        // Signup
        if (!name || !email || !password || (userType === 'parent' && !childEmail)) {
          throw new Error('Please fill in all fields');
        }
        if (!validateName(name)) {
          throw new Error(getNameErrorMessage(name));
        }
        if (!validateEmail(email)) {
          throw new Error(getEmailErrorMessage(email));
        }
        if (!validatePassword(password)) {
          throw new Error(getPasswordErrorMessage(password));
        }
        if (userType === 'parent') {
          if (!validateEmail(childEmail)) {
            throw new Error('Please enter a valid email for your child');
          }
          const childExists = await checkUserExists(childEmail);
          if (!childExists) {
            throw new Error('Child email is not registered in our system');
          }
        }
        await signUp(email, password, name, userType, userType === 'parent' ? childEmail : null);
        navigate('/');
      }
    } catch (error) {
      setError(error.message);
    } finally {
      setLoading(false);
    }
  };

  const getFieldError = (fieldName) => {
    if (!submitted) return '';
    switch (fieldName) {
      case 'name':
        return getNameErrorMessage(name);
      case 'email':
        return getEmailErrorMessage(email);
      case 'password':
        return getPasswordErrorMessage(password);
      case 'childEmail':
        return getEmailErrorMessage(childEmail);
      default:
        return '';
    }
  };

  return (
    <Container component="main" maxWidth="xs" disableGutters={isMobile}>
      <StyledPaper elevation={isMobile ? 0 : 6}>
        <Box display="flex" flexDirection="column" alignItems="center" width="100%">
          <Logo variant="default" width={isMobile ? 60 : 80} />
        </Box>
        <Tabs
          value={tab}
          onChange={handleTabChange}
          centered
          sx={{
            mt: 2,
            '& .MuiTab-root': { color: 'text.secondary' },
            '& .Mui-selected': { color: 'primary.main' }
          }}
        >
          <Tab label="Login" />
          <Tab label="Sign Up" />
        </Tabs>
        {error && (
          <Typography color="error" align="center" sx={{ mt: 2 }}>
            {error}
          </Typography>
        )}
        <Form onSubmit={handleSubmit}>
          {tab === 1 && (
            <>
              <TextField
                variant="outlined"
                margin="normal"
                required
                fullWidth
                id="name"
                label="Full Name"
                name="name"
                autoComplete="name"
                value={name}
                onChange={(e) => setName(e.target.value)}
                error={!!getFieldError('name')}
                helperText={getFieldError('name')}
              />
              <FormControl fullWidth variant="outlined" margin="normal">
                <InputLabel id="user-type-label">I am a</InputLabel>
                <Select
                  labelId="user-type-label"
                  id="user-type"
                  value={userType}
                  onChange={(e) => setUserType(e.target.value)}
                  label="I am a"
                >
                  <MenuItem value="student">Student</MenuItem>
                  <MenuItem value="parent">Parent</MenuItem>
                </Select>
              </FormControl>
            </>
          )}
          <TextField
            variant="outlined"
            margin="normal"
            required
            fullWidth
            id="email"
            label={tab === 1 && userType === 'student' ? "School Email Address" : "Email Address"}
            name="email"
            autoComplete="email"
            value={email}
            onChange={(e) => setEmail(e.target.value)}
            error={!!getFieldError('email')}
            helperText={getFieldError('email')}
          />
          {tab === 1 && userType === 'parent' && (
            <TextField
              variant="outlined"
              margin="normal"
              required
              fullWidth
              id="childEmail"
              label="Child's School Email Address"
              name="childEmail"
              value={childEmail}
              onChange={(e) => setChildEmail(e.target.value)}
              error={!!getFieldError('childEmail')}
              helperText={getFieldError('childEmail')}
            />
          )}
          <TextField
            variant="outlined"
            margin="normal"
            required
            fullWidth
            name="password"
            label="Password"
            type="password"
            id="password"
            autoComplete={tab === 0 ? "current-password" : "new-password"}
            value={password}
            onChange={(e) => setPassword(e.target.value)}
            error={!!getFieldError('password')}
            helperText={getFieldError('password')}
            InputProps={{
              style: { backgroundColor: 'transparent' },
            }}
          />
          <SubmitButton
            type="submit"
            fullWidth
            variant="contained"
            color="primary"
            disabled={loading}
          >
            {loading ? <CircularProgress size={24} /> : (tab === 0 ? 'Sign In' : 'Sign Up')}
          </SubmitButton>
        </Form>
        {tab === 0 && (
          <Link href="/forgot-password" variant="body2" sx={{ color: 'text.secondary', mt: 2 }}>
            Forgot password?
          </Link>
        )}
        <Button
          fullWidth
          variant="outlined"
          color="primary"
          onClick={() => navigate('/demo')}
          sx={{ mt: 2 }}
        >
          Try Demo
        </Button>
      </StyledPaper>
    </Container>
  );
};

export default AuthPage;

================
File: src/pages/DemoPage.js
================
import React, { useState, useEffect } from 'react';
import { Container, Typography, Button, Box, CircularProgress } from '@mui/material';
import { useNavigate } from 'react-router-dom';
import { signInAnonymously, onAuthStateChanged } from 'firebase/auth';
import { setDoc, doc } from 'firebase/firestore';
import { auth, db } from '../firebase';

const DemoPage = () => {
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const navigate = useNavigate();

  useEffect(() => {
    const unsubscribe = onAuthStateChanged(auth, (user) => {
      if (user) {
        navigate('/');
      }
    });

    return () => unsubscribe();
  }, [navigate]);

  const handleDemoLogin = async () => {
    setLoading(true);
    setError('');

    try {
      const { user } = await signInAnonymously();
      await setDoc(doc(db, 'users', user.uid), {
        name: 'Demo User',
        email: 'demo@example.com',
        userType: 'demo',
        createdAt: new Date(),
      });
      // Navigation will be handled by the useEffect
    } catch (error) {
      console.error('Error during demo login:', error);
      setError('Failed to start demo. Please try again. Error: ' + error.message);
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Box
        sx={{
          marginTop: 8,
          display: 'flex',
          flexDirection: 'column',
          alignItems: 'center',
        }}
      >
        <Typography component="h1" variant="h4" gutterBottom>
          Welcome to Zwisch Demo
        </Typography>
        <Typography variant="body1" align="center" paragraph>
          Experience Zwisch without creating an account. This demo allows you to explore the app's features with sample data.
        </Typography>
        {error && (
          <Typography color="error" align="center" paragraph>
            {error}
          </Typography>
        )}
        <Button
          variant="contained"
          color="primary"
          onClick={handleDemoLogin}
          disabled={loading}
          sx={{ mt: 2 }}
        >
          {loading ? <CircularProgress size={24} /> : 'Start Demo'}
        </Button>
        <Button
          variant="text"
          color="primary"
          onClick={() => navigate('/auth')}
          sx={{ mt: 2 }}
        >
          Back to Login
        </Button>
      </Box>
    </Container>
  );
};

export default DemoPage;

================
File: src/pages/ForgotPassword.js
================
import React, { useState } from 'react';
import { TextField, Button, Typography, Container, Box, Paper, IconButton, useMediaQuery } from '@mui/material';
import { styled, useTheme } from '@mui/system';
import { useNavigate } from 'react-router-dom';
import { auth } from '../firebase';
import Logo from '../components/Logo';
import Brightness4Icon from '@mui/icons-material/Brightness4';
import Brightness7Icon from '@mui/icons-material/Brightness7';

const StyledPaper = styled(Paper)(({ theme }) => ({
    marginTop: theme.spacing(8),
    display: 'flex',
    flexDirection: 'column',
    alignItems: 'center',
    padding: theme.spacing(4),
    backgroundColor: theme.palette.background.paper,
    borderRadius: theme.shape.borderRadius,
    boxShadow: theme.shadows[5],
    [theme.breakpoints.down('sm')]: {
        marginTop: 0,
        height: '100vh',
        borderRadius: 0,
    },
}));

const Form = styled('form')(({ theme }) => ({
    width: '100%',
    marginTop: theme.spacing(1),
}));

const SubmitButton = styled(Button)(({ theme }) => ({
    margin: theme.spacing(3, 0, 2),
}));

const Background = styled(Box)(({ theme }) => ({
    position: 'fixed',
    top: 0,
    left: 0,
    right: 0,
    bottom: 0,
    zIndex: -1,
    overflow: 'hidden',
    backgroundColor: theme.palette.background.default,
    '& svg': {
        position: 'absolute',
        width: '100%',
        height: '100%',
    },
    '& path': {
        stroke: theme.palette.primary.main,
        strokeWidth: 2,
        fill: 'none',
        animation: 'moveStreak 20s linear infinite',
    },
    '@keyframes moveStreak': {
        '0%': { transform: 'translateX(-100%) translateY(-100%)' },
        '100%': { transform: 'translateX(100%) translateY(100%)' },
    },
}));

const ForgotPassword = ({ darkMode, toggleDarkMode }) => {
    const [email, setEmail] = useState('');
    const [message, setMessage] = useState('');
    const [error, setError] = useState('');
    const [loading, setLoading] = useState(false);
    const navigate = useNavigate();
    const theme = useTheme();
    const isMobile = useMediaQuery(theme.breakpoints.down('sm'));

    const handleResetPassword = async (e) => {
        e.preventDefault();
        setLoading(true);
        setMessage('');
        setError('');

        try {
            await auth.sendPasswordResetEmail(email);
            setMessage('Check your email for further instructions');
        } catch (error) {
            setError('Failed to reset password. ' + error.message);
        } finally {
            setLoading(false);
        }
    };

    return (
        <>
            <Background>
                <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 1440 800" preserveAspectRatio="none">
                    <path d="M-100,200 C300,100 600,400 1000,200 S1400,400 1800,300" />
                    <path d="M-100,400 C200,300 600,600 1000,400 S1400,600 1800,500" style={{ animationDelay: "-5s" }} />
                    <path d="M-100,600 C300,500 600,800 1000,600 S1400,800 1800,700" style={{ animationDelay: "-10s" }} />
                    <path d="M-100,100 C200,200 600,50 1000,100 S1400,200 1800,100" style={{ animationDelay: "-15s" }} />
                    <path d="M-100,700 C300,600 600,900 1000,700 S1400,900 1800,800" style={{ animationDelay: "-7s" }} />
                </svg>
            </Background>
            <Container component="main" maxWidth="xs" disableGutters={isMobile}>
                <StyledPaper elevation={isMobile ? 0 : 6}>
                    <Box display="flex" justifyContent="space-between" alignItems="center" width="100%">
                        <Logo variant="default" width={isMobile ? 60 : 80} />
                        <IconButton onClick={toggleDarkMode} color="inherit">
                            {darkMode ? <Brightness7Icon /> : <Brightness4Icon />}
                        </IconButton>
                    </Box>
                    <Typography variant="h5" align="center" gutterBottom sx={{ mt: 2 }}>
                        Reset Your Password
                    </Typography>
                    {error && (
                        <Typography color="error" align="center">
                            {error}
                        </Typography>
                    )}
                    {message && (
                        <Typography color="primary" align="center">
                            {message}
                        </Typography>
                    )}
                    <Form onSubmit={handleResetPassword}>
                        <TextField
                            variant="outlined"
                            margin="normal"
                            required
                            fullWidth
                            id="email"
                            label="Email Address"
                            name="email"
                            autoComplete="email"
                            autoFocus
                            value={email}
                            onChange={(e) => setEmail(e.target.value)}
                        />
                        <SubmitButton
                            type="submit"
                            fullWidth
                            variant="contained"
                            color="primary"
                            disabled={loading}
                        >
                            {loading ? 'Sending...' : 'Reset Password'}
                        </SubmitButton>
                    </Form>
                    <Button
                        fullWidth
                        variant="text"
                        color="primary"
                        onClick={() => navigate('/auth')}
                        sx={{ mt: 2 }}
                    >
                        Back to Login
                    </Button>
                </StyledPaper>
            </Container>
        </>
    );
};

export default ForgotPassword;

================
File: src/pages/Home.js
================
import React from 'react';
import { Typography, Button, Container } from '@mui/material';
import { Link } from 'react-router-dom';

const Home = () => {
  return (
    <Container maxWidth="sm" style={{ marginTop: '2rem', textAlign: 'center' }}>
      <Typography variant="h4" gutterBottom>
        Welcome to Zwisch
      </Typography>
      <Typography variant="body1" paragraph>
        Connect with fellow students for eco-friendly rides to school.
      </Typography>
      <Button
        variant="contained"
        color="primary"
        component={Link}
        to="/request-ride"
        style={{ marginRight: '1rem' }}
      >
        Request a Ride
      </Button>
      <Button
        variant="contained"
        color="secondary"
        component={Link}
        to="/offer-ride"
      >
        Offer a Ride
      </Button>
    </Container>
  );
};

export default Home;

================
File: src/pages/Login.js
================
import React, { useState } from 'react';
import { TextField, Button, Typography, Container } from '@mui/material';
import { auth } from '../firebase';
import { useNavigate } from 'react-router-dom';

const Login = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [error, setError] = useState('');
  const history = useNavigate();

  const handleLogin = async (e) => {
    e.preventDefault();
    try {
      await auth.signInWithEmailAndPassword(email, password);
      history.push('/');
    } catch (error) {
      setError(error.message);
    }
  };

  return (
    <Container maxWidth="xs" style={{ marginTop: '2rem' }}>
      <Typography variant="h4" align="center" gutterBottom>
        Login
      </Typography>
      {error && (
        <Typography color="error" align="center">
          {error}
        </Typography>
      )}
      <form onSubmit={handleLogin}>
        <TextField
          variant="outlined"
          margin="normal"
          required
          fullWidth
          id="email"
          label="Email Address"
          name="email"
          autoComplete="email"
          autoFocus
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <TextField
          variant="outlined"
          margin="normal"
          required
          fullWidth
          name="password"
          label="Password"
          type="password"
          id="password"
          autoComplete="current-password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <Button
          type="submit"
          fullWidth
          variant="contained"
          color="primary"
          style={{ marginTop: '1rem' }}
        >
          Login
        </Button>
      </form>
    </Container>
  );
};

export default Login;

================
File: src/pages/OfferRide.js
================
import React, { useState, useContext, useEffect } from 'react';
import { Container, Typography, TextField, Button, CircularProgress, Box, List, ListItem, ListItemText } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db } from '../firebase';
import { collection, addDoc, query, where, getDocs, orderBy, Timestamp } from 'firebase/firestore';
import { matchRideOffer } from '../utils/aiMatching';
import { performRideMatching } from '../utils/rideMatching';

const OfferRide = () => {
  const [offer, setOffer] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [offers, setOffers] = useState([]);
  const { currentUser } = useContext(AuthContext);

  useEffect(() => {
    fetchOffers();
  }, [currentUser]);

  const fetchOffers = async () => {
    try {
      const q = query(
        collection(db, 'driverAvailability'),
        where('userId', '==', currentUser.uid),
        orderBy('createdAt', 'desc')
      );
      const querySnapshot = await getDocs(q);
      const offersData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setOffers(offersData);
    } catch (error) {
      console.error('Error fetching ride offers:', error);
      setError('Failed to fetch ride offers. Please try again.');
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      console.log('Processing ride offer...');
      const processedOffer = await matchRideOffer(offer);
      console.log('Processed offer:', processedOffer);

      console.log('Adding offer to Firestore...');
      const docRef = await addDoc(collection(db, 'driverAvailability'), {
        userId: currentUser.uid,
        userEmail: currentUser.email,
        rawOffer: offer,
        processedOffer,
        status: 'active',
        createdAt: Timestamp.now(),
      });
      console.log('Offer added with ID:', docRef.id);

      console.log('Performing ride matching...');
      await performRideMatching();
      console.log('Ride matching completed');

      setOffer('');
      await fetchOffers();
      console.log('Offers fetched and updated');
    } catch (error) {
      console.error('Error submitting ride offer:', error);
      setError(`Failed to submit ride offer. Please try again. ${error.message}`);

      if (error.stack) {
        console.error('Error stack:', error.stack);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Typography variant="h4" gutterBottom>
        Offer a Ride
      </Typography>
      {error && (
        <Typography color="error" gutterBottom>
          {error}
        </Typography>
      )}
      <form onSubmit={handleSubmit}>
        <TextField
          fullWidth
          label="Describe your ride offer"
          multiline
          rows={4}
          value={offer}
          onChange={(e) => setOffer(e.target.value)}
          margin="normal"
          placeholder="E.g., Available for morning rides on weekdays from 7 AM to 9 AM, prefer pickups in downtown area"
          disabled={loading}
        />
        <Button
          type="submit"
          variant="contained"
          color="primary"
          disabled={loading}
          sx={{ mt: 2 }}
        >
          {loading ? <CircularProgress size={24} /> : 'Submit Offer'}
        </Button>
      </form>
      <Box mt={4}>
        <Typography variant="h6" gutterBottom>
          Your Ride Offers
        </Typography>
        <List>
          {offers.map((ofr) => (
            <ListItem key={ofr.id}>
              <ListItemText
                primary={ofr.rawOffer}
                secondary={`Status: ${ofr.status} | Created: ${ofr.createdAt.toDate().toLocaleString()}`}
              />
            </ListItem>
          ))}
        </List>
      </Box>
    </Container>
  );
};

export default OfferRide;

================
File: src/pages/Profile.js
================
import React, { useState, useEffect, useContext } from 'react';
import { Container, Typography, TextField, Button, Grid, CircularProgress, Box, Select, MenuItem, FormControl, InputLabel } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db, auth } from '../firebase';
import { doc, getDoc, updateDoc } from 'firebase/firestore';
import { useNavigate } from 'react-router-dom';

const Profile = () => {
  const { currentUser } = useContext(AuthContext);
  const [profile, setProfile] = useState(null);
  const [loading, setLoading] = useState(true);
  const [saving, setSaving] = useState(false);
  const navigate = useNavigate();

  useEffect(() => {
    const fetchProfile = async () => {
      try {
        const profileDoc = await getDoc(doc(db, 'users', currentUser.uid));
        setProfile(profileDoc.data());
      } catch (error) {
        console.error('Error fetching profile:', error);
      } finally {
        setLoading(false);
      }
    };

    fetchProfile();
  }, [currentUser]);

  const handleChange = (e) => {
    setProfile({ ...profile, [e.target.name]: e.target.value });
  };

  const handleSave = async () => {
    setSaving(true);
    try {
      await updateDoc(doc(db, 'users', currentUser.uid), profile);
      alert('Profile updated successfully!');
    } catch (error) {
      console.error('Error updating profile:', error);
      alert('Failed to update profile. Please try again.');
    } finally {
      setSaving(false);
    }
  };

  const handleLogout = async () => {
    try {
      await auth.signOut();
      navigate('/auth');
    } catch (error) {
      console.error('Error signing out:', error);
    }
  };

  if (loading) {
    return <CircularProgress />;
  }

  return (
    <Container maxWidth="sm">
      <Typography variant="h4" gutterBottom>
        User Profile
      </Typography>
      <Grid container spacing={2}>
        <Grid item xs={12}>
          <TextField
            fullWidth
            label="Name"
            name="name"
            value={profile?.name || ''}
            onChange={handleChange}
            margin="normal"
          />
        </Grid>
        <Grid item xs={12}>
          <TextField
            fullWidth
            label="Email"
            name="email"
            value={profile?.email || ''}
            disabled
            margin="normal"
          />
        </Grid>
        <Grid item xs={12}>
          <FormControl fullWidth margin="normal">
            <InputLabel id="role-label">Role</InputLabel>
            <Select
              labelId="role-label"
              id="role"
              name="userType"
              value={profile?.userType || ''}
              label="Role"
              onChange={handleChange}
            >
              <MenuItem value="student">Student</MenuItem>
              <MenuItem value="parent">Parent</MenuItem>
            </Select>
          </FormControl>
        </Grid>
        <Grid item xs={12}>
          <Box display="flex" justifyContent="space-between">
            <Button
              variant="contained"
              color="primary"
              onClick={handleSave}
              disabled={saving}
            >
              {saving ? 'Saving...' : 'Save Changes'}
            </Button>
            <Button
              variant="outlined"
              color="secondary"
              onClick={handleLogout}
            >
              Logout
            </Button>
          </Box>
        </Grid>
      </Grid>
    </Container>
  );
};

export default Profile;

================
File: src/pages/RequestRide.js
================
import React, { useState, useContext, useEffect } from 'react';
import { Container, Typography, TextField, Button, CircularProgress, Box, List, ListItem, ListItemText } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db, collection, addDoc, query, where, getDocs, orderBy, serverTimestamp } from '../firebase';
import { matchRideRequest } from '../utils/aiMatching';
import { performRideMatching } from '../utils/rideMatching';

const RequestRide = () => {
  const [request, setRequest] = useState('');
  const [loading, setLoading] = useState(false);
  const [error, setError] = useState('');
  const [requests, setRequests] = useState([]);
  const { currentUser } = useContext(AuthContext);

  useEffect(() => {
    if (currentUser) {
      fetchRequests();
    }
  }, [currentUser]);

  const fetchRequests = async () => {
    try {
      const q = query(
        collection(db, 'rideRequests'),
        where('userId', '==', currentUser.uid),
        orderBy('createdAt', 'desc')
      );
      const querySnapshot = await getDocs(q);
      const requestsData = querySnapshot.docs.map(doc => ({ id: doc.id, ...doc.data() }));
      setRequests(requestsData);
    } catch (error) {
      console.error('Error fetching ride requests:', error);
      setError('Failed to fetch ride requests. Please try again.');
    }
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setLoading(true);
    setError('');

    try {
      console.log('Processing ride request...');
      const processedRequest = await matchRideRequest(request);
      console.log('Processed request:', processedRequest);

      console.log('Adding request to Firestore...');
      const docRef = await addDoc(collection(db, 'rideRequests'), {
        userId: currentUser.uid,
        userEmail: currentUser.email,
        rawRequest: request,
        processedRequest,
        status: 'pending',
        createdAt: serverTimestamp(),
      });
      console.log('Request added with ID:', docRef.id);

      console.log('Performing ride matching...');
      await performRideMatching();
      console.log('Ride matching completed');

      setRequest('');
      await fetchRequests();
      console.log('Requests fetched and updated');
    } catch (error) {
      console.error('Error submitting ride request:', error);
      setError(`Failed to submit ride request. Please try again. ${error.message}`);

      if (error.stack) {
        console.error('Error stack:', error.stack);
      }
    } finally {
      setLoading(false);
    }
  };

  return (
    <Container maxWidth="sm">
      <Typography variant="h4" gutterBottom>
        Request a Ride
      </Typography>
      {error && (
        <Typography color="error" gutterBottom>
          {error}
        </Typography>
      )}
      <form onSubmit={handleSubmit}>
        <TextField
          fullWidth
          label="Describe your ride request"
          multiline
          rows={4}
          value={request}
          onChange={(e) => setRequest(e.target.value)}
          margin="normal"
          placeholder="E.g., Need a ride to school tomorrow morning from 123 Main St at 8 AM"
          disabled={loading}
        />
        <Button
          type="submit"
          variant="contained"
          color="primary"
          disabled={loading}
          sx={{ mt: 2 }}
        >
          {loading ? <CircularProgress size={24} /> : 'Submit Request'}
        </Button>
      </form>
      <Box mt={4}>
        <Typography variant="h6" gutterBottom>
          Your Ride Requests
        </Typography>
        <List>
          {requests.map((req) => (
            <ListItem key={req.id}>
              <ListItemText
                primary={req.rawRequest}
                secondary={`Status: ${req.status} | Created: ${req.createdAt?.toDate().toLocaleString() || 'N/A'}`}
              />
            </ListItem>
          ))}
        </List>
      </Box>
    </Container>
  );
};

export default RequestRide;

================
File: src/pages/RideHistory.js
================
import React, { useState, useEffect, useContext } from 'react';
import { Container, Typography, List, ListItem, ListItemText, Divider } from '@mui/material';
import { AuthContext } from '../contexts/AuthContext';
import { db } from '../firebase';

const RideHistory = () => {
  const [rides, setRides] = useState([]);
  const { currentUser } = useContext(AuthContext);

  useEffect(() => {
    const fetchRides = async () => {
      try {
        const ridesSnapshot = await db

          .collection('rides')
          .where('userId', '==', currentUser.uid)
          .orderBy('createdAt', 'desc')
          .get();

        const ridesData = ridesSnapshot.docs.map(doc => ({
          id: doc.id,
          ...doc.data()
        }));

        setRides(ridesData);
      } catch (error) {
        console.error('Error fetching ride history:', error);
      }
    };

    fetchRides();
  }, [currentUser]);

  return (
    <Container maxWidth="md" style={{ marginTop: '2rem' }}>
      <Typography variant="h4" gutterBottom>
        Ride History
      </Typography>
      <List>
        {rides.map((ride, index) => (
          <React.Fragment key={ride.id}>
            <ListItem>
              <ListItemText
                primary={`${ride.pickup} to ${ride.destination}`}
                secondary={`Date: ${ride.date}, Time: ${ride.time}, Status: ${ride.status}`}
              />
            </ListItem>
            {index < rides.length - 1 && <Divider />}
          </React.Fragment>
        ))}
      </List>
      {rides.length === 0 && (
        <Typography>No ride history found.</Typography>
      )}
    </Container>
  );
};

export default RideHistory;

================
File: src/pages/Signup.js
================
import React, { useState } from 'react';
import { TextField, Button, Typography, Container, MenuItem, Checkbox, FormControlLabel, Link } from '@mui/material';
import {
  auth, db
} from '../firebase';
import { useNavigate } from 'react-router-dom';

const Signup = () => {
  const [email, setEmail] = useState('');
  const [password, setPassword] = useState('');
  const [name, setName] = useState('');
  const [role, setRole] = useState('');
  const [error, setError] = useState('');
  const [termsAgreed, setTermsAgreed] = useState(false);
  const history = useNavigate();

  const handleSignup = async (e) => {
    e.preventDefault();
    if (!termsAgreed) {
      setError('You must agree to the Terms and Conditions and Privacy Policy');
      return;
    }
    try {
      const { user } = await auth.createUserWithEmailAndPassword(email, password);
      await db
        .collection('users').doc(user.uid).set({
          name,
          email,
          role,
          createdAt: new Date(),
        });
      history.push('/');
    } catch (error) {
      setError(error.message);
    }
  };

  return (
    <Container maxWidth="xs" style={{ marginTop: '2rem' }}>
      <Typography variant="h4" align="center" gutterBottom>
        Sign Up
      </Typography>
      {error && (
        <Typography color="error" align="center">
          {error}
        </Typography>
      )}
      <form onSubmit={handleSignup}>
        <TextField
          variant="outlined"
          margin="normal"
          required
          fullWidth
          id="name"
          label="Full Name"
          name="name"
          autoComplete="name"
          autoFocus
          value={name}
          onChange={(e) => setName(e.target.value)}
        />
        <TextField
          variant="outlined"
          margin="normal"
          required
          fullWidth
          id="email"
          label="Email Address"
          name="email"
          autoComplete="email"
          value={email}
          onChange={(e) => setEmail(e.target.value)}
        />
        <TextField
          variant="outlined"
          margin="normal"
          required
          fullWidth
          name="password"
          label="Password"
          type="password"
          id="password"
          autoComplete="new-password"
          value={password}
          onChange={(e) => setPassword(e.target.value)}
        />
        <TextField
          select
          variant="outlined"
          margin="normal"
          required
          fullWidth
          name="role"
          label="Role"
          id="role"
          value={role}
          onChange={(e) => setRole(e.target.value)}
        >
          <MenuItem value="student">Student</MenuItem>
          <MenuItem value="parent">Parent</MenuItem>
        </TextField>
        <FormControlLabel
          control={
            <Checkbox
              checked={termsAgreed}
              onChange={(e) => setTermsAgreed(e.target.checked)}
              color="primary"
            />
          }
          label={
            <Typography variant="body2">
              I agree to the{' '}
              <Link href="https://zwisch.app/terms_and_conditions.html" target="_blank" rel="noopener">
                Terms and Conditions
              </Link>{' '}
              and{' '}
              <Link href="https://zwisch.app/privacy_policy.html" target="_blank" rel="noopener">
                Privacy Policy
              </Link>
            </Typography>
          }
        />
        <Button
          type="submit"
          fullWidth
          variant="contained"
          color="primary"
          style={{ marginTop: '1rem' }}
        >
          Sign Up
        </Button>
      </form>
    </Container>
  );
};

export default Signup;

================
File: src/utils/aiMatching.js
================
import { GoogleGenerativeAI } from "@google/generative-ai";

const genAI = new GoogleGenerativeAI("AIzaSyAFzMiQJNJXPyQuQ9X2SlS7VvhAK8yqjsI");

export const matchRideRequest = async (request) => {
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const prompt = `
    Analyze the following ride request and extract key information:
    "${request}"
    
    Please provide a JSON response with the following structure:
    {
      "type": "one-time" or "recurring",
      "pickup": "extracted pickup location",
      "destination": "extracted destination",
      "date": "extracted date (YYYY-MM-DD format) or 'recurring'",
      "time": "extracted time (HH:MM format)",
      "frequency": "daily", "weekdays", or "weekly" (if recurring),
      "passengers": "number of passengers (default to 1 if not specified)"
    }
    
    Provide only the JSON object without any additional text or formatting.
  `;

  try {
    console.log('Sending request to Gemini API...');
    const result = await model.generateContent(prompt);
    console.log('Received response from Gemini API');
    const response = await result.response;
    let text = response.text();
    console.log('Raw response:', text);

    // Remove any markdown formatting
    text = text.replace(/```json\n?/, '').replace(/```\n?/, '').trim();
    console.log('Cleaned response:', text);

    const parsedResponse = JSON.parse(text);
    console.log('Parsed response:', parsedResponse);
    return parsedResponse;
  } catch (error) {
    console.error("Error in matchRideRequest:", error);
    if (error.response) {
      console.error("API response:", error.response);
    }
    throw new Error(`Failed to process ride request: ${error.message}`);
  }
};

export const matchRideOffer = async (availability) => {
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const prompt = `
    Analyze the following driver availability and extract key information:
    "${availability}"
    
    Please provide a JSON response with the following structure:
    {
      "type": "one-time" or "recurring",
      "startLocation": "extracted start location",
      "route": ["list of areas or stops along the route"],
      "date": "extracted date (YYYY-MM-DD format) or 'recurring'",
      "time": "extracted time (HH:MM format)",
      "frequency": "daily", "weekdays", or "weekly" (if recurring),
      "seats": "number of available seats (default to 4 if not specified)"
    }
    
    Provide only the JSON object without any additional text or formatting.
  `;

  try {
    console.log('Sending request to Gemini API...');
    const result = await model.generateContent(prompt);
    console.log('Received response from Gemini API');
    const response = await result.response;
    let text = response.text();
    console.log('Raw response:', text);

    // Remove any markdown formatting
    text = text.replace(/```json\n?/, '').replace(/```\n?/, '').trim();
    console.log('Cleaned response:', text);

    const parsedResponse = JSON.parse(text);
    console.log('Parsed response:', parsedResponse);
    return parsedResponse;
  } catch (error) {
    console.error("Error in matchRideOffer:", error);
    if (error.response) {
      console.error("API response:", error.response);
    }
    throw new Error(`Failed to process driver availability: ${error.message}`);
  }
};

export const matchRides = async (requests, availabilities) => {
  const model = genAI.getGenerativeModel({ model: "gemini-pro" });

  const prompt = `
    Given the following ride requests and driver availabilities, match them based on compatibility:
    
    Requests: ${JSON.stringify(requests)}
    Availabilities: ${JSON.stringify(availabilities)}
    
    Please provide a JSON response with the following structure:
    [
      {
        "requestId": "ID of the matched request",
        "availabilityId": "ID of the matched availability",
        "compatibilityScore": "A number between 0 and 1 indicating how well they match",
        "type": "one-time" or "recurring"
      },
      ...
    ]
    
    Consider factors such as location proximity, time compatibility, available seats, and whether it's a one-time ride or a recurring carpool.
    For recurring carpools, ensure that the frequencies match (e.g., both are 'daily' or both are 'weekdays').
    Prioritize matches with higher compatibility scores.
    
    Provide only the JSON array without any additional text or formatting.
  `;

  try {
    console.log('Sending request to Gemini API...');
    const result = await model.generateContent(prompt);
    console.log('Received response from Gemini API');
    const response = await result.response;
    let text = response.text();
    console.log('Raw response:', text);

    // Remove any markdown formatting
    text = text.replace(/```json\n?/, '').replace(/```\n?/, '').trim();
    console.log('Cleaned response:', text);

    const parsedResponse = JSON.parse(text);
    console.log('Parsed response:', parsedResponse);
    return parsedResponse;
  } catch (error) {
    console.error("Error in matchRides:", error);
    if (error.response) {
      console.error("API response:", error.response);
    }
    throw new Error(`Failed to match rides: ${error.message}`);
  }
};

================
File: src/utils/formValidation.js
================
export const validateEmail = (email) => {
    const re = /^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$/;
    return re.test(String(email).toLowerCase());
  };
  
  export const validateSchoolEmail = (email) => {
    // This is a simple check. You might want to implement a more sophisticated validation
    // based on your specific requirements or a list of approved school domains.
    return email.endsWith('.edu');
  };
  
  export const validatePassword = (password) => {
    // Require at least 8 characters, one uppercase letter, one lowercase letter, and one number
    const re = /^(?=.*\d)(?=.*[a-z])(?=.*[A-Z]).{8,}$/;
    return re.test(password);
  };
  
  export const validateName = (name) => {
    return name.trim().length > 0;
  };
  
  export const getEmailErrorMessage = (email) => {
    if (!email) return "Email is required";
    if (!validateEmail(email)) return "Invalid email address";
    if (!validateSchoolEmail(email)) return "Please use a valid school email address";
    return "";
  };
  
  export const getPasswordErrorMessage = (password) => {
    if (!password) return "Password is required";
    if (!validatePassword(password)) return "Password must be at least 8 characters long and contain at least one uppercase letter, one lowercase letter, and one number";
    return "";
  };
  
  export const getNameErrorMessage = (name) => {
    if (!name) return "Name is required";
    if (!validateName(name)) return "Please enter a valid name";
    return "";
  };

================
File: src/utils/rideMatching.js
================
import { db } from '../firebase';
import { matchRides } from './aiMatching';
import { collection, query, where, getDocs, getDoc, doc, addDoc, updateDoc } from 'firebase/firestore';

export const performRideMatching = async () => {
  try {
    const requestsQuery = query(collection(db, 'rideRequests'), where('status', '==', 'pending'));
    const requestsSnapshot = await getDocs(requestsQuery);

    const availabilitiesQuery = query(collection(db, 'driverAvailability'), where('status', '==', 'active'));
    const availabilitiesSnapshot = await getDocs(availabilitiesQuery);

    const requests = await Promise.all(requestsSnapshot.docs.map(async (docSnapshot) => {
      const userData = await getDoc(doc(db, 'users', docSnapshot.data().userId));
      return {
        id: docSnapshot.id,
        ...docSnapshot.data(),
        userEmail: userData.data().email
      };
    }));

    const availabilities = await Promise.all(availabilitiesSnapshot.docs.map(async (docSnapshot) => {
      const userData = await getDoc(doc(db, 'users', docSnapshot.data().userId));
      return {
        id: docSnapshot.id,
        ...docSnapshot.data(),
        userEmail: userData.data().email
      };
    }));

    // Group requests and availabilities by school domain
    const groupedRequests = groupBySchoolDomain(requests);
    const groupedAvailabilities = groupBySchoolDomain(availabilities);

    let allMatches = [];

    // Perform matching for each school domain
    for (const domain in groupedRequests) {
      if (groupedAvailabilities[domain]) {
        const domainMatches = await matchRides(groupedRequests[domain], groupedAvailabilities[domain]);
        allMatches = allMatches.concat(domainMatches);
      }
    }

    // Process matches
    for (const match of allMatches) {
      const { requestId, availabilityId, compatibilityScore, type } = match;

      if (compatibilityScore > 0.7) {
        if (type === 'one-time') {
          await createOneTimeRide(requestId, availabilityId);
        } else if (type === 'recurring') {
          await createRecurringCarpool(requestId, availabilityId);
        }

        await createMatchNotifications(requestId, availabilityId, type);
      }
    }

    console.log('Ride matching completed successfully');
    return allMatches;
  } catch (error) {
    console.error('Error in ride matching:', error);
    throw error;
  }
};

const groupBySchoolDomain = (items) => {
  return items.reduce((acc, item) => {
    const domain = item.userEmail.split('@')[1];
    if (!acc[domain]) {
      acc[domain] = [];
    }
    acc[domain].push(item);
    return acc;
  }, {});
};

const createOneTimeRide = async (requestId, availabilityId) => {
  const rideRef = await addDoc(collection(db, 'rides'), {
    requestId,
    availabilityId,
    status: 'matched',
    type: 'one-time',
    createdAt: new Date()
  });

  await updateDoc(doc(db, 'rideRequests', requestId), { status: 'matched', rideId: rideRef.id });
  await updateDoc(doc(db, 'driverAvailability', availabilityId), { status: 'matched', rideId: rideRef.id });
};

const createRecurringCarpool = async (requestId, availabilityId) => {
  const carpoolRef = await addDoc(collection(db, 'carpools'), {
    requestId,
    availabilityId,
    status: 'active',
    type: 'recurring',
    createdAt: new Date()
  });

  await updateDoc(doc(db, 'rideRequests', requestId), { status: 'matched', carpoolId: carpoolRef.id });
  await updateDoc(doc(db, 'driverAvailability', availabilityId), { status: 'matched', carpoolId: carpoolRef.id });
};

const createMatchNotifications = async (requestId, availabilityId, type) => {
  const requestDoc = await getDoc(doc(db, 'rideRequests', requestId));
  const availabilityDoc = await getDoc(doc(db, 'driverAvailability', availabilityId));

  const rideType = type === 'one-time' ? 'ride' : 'carpool';

  await addDoc(collection(db, 'notifications'), {
    userId: requestDoc.data().userId,
    title: `${rideType.charAt(0).toUpperCase() + rideType.slice(1)} Matched`,
    message: `Your ${rideType} request has been matched! Check your ${rideType}s for details.`,
    read: false,
    createdAt: new Date()
  });

  await addDoc(collection(db, 'notifications'), {
    userId: availabilityDoc.data().userId,
    title: `${rideType.charAt(0).toUpperCase() + rideType.slice(1)} Matched`,
    message: `Your ${rideType} offer has been matched! Check your ${rideType}s for details.`,
    read: false,
    createdAt: new Date()
  });
};

export const runMatchingOnNewEntry = async () => {
  await performRideMatching();
};

================
File: src/App.css
================
.App {
  text-align: center;
}

.App-logo {
  height: 40vmin;
  pointer-events: none;
}

@media (prefers-reduced-motion: no-preference) {
  .App-logo {
    animation: App-logo-spin infinite 20s linear;
  }
}

.App-header {
  background-color: #282c34;
  min-height: 100vh;
  display: flex;
  flex-direction: column;
  align-items: center;
  justify-content: center;
  font-size: calc(10px + 2vmin);
  color: white;
}

.App-link {
  color: #61dafb;
}

@keyframes App-logo-spin {
  from {
    transform: rotate(0deg);
  }
  to {
    transform: rotate(360deg);
  }
}

================
File: src/App.js
================
import React, { useState } from 'react';
import { BrowserRouter as Router, Route, Routes, Navigate } from 'react-router-dom';
import { AuthProvider } from './contexts/AuthContext';
import { NotificationsProvider } from './contexts/NotificationsContext';
import { ThemeProvider } from '@mui/material/styles';
import { CssBaseline } from '@mui/material';
import { lightTheme, darkTheme } from './theme';
import PrivateRoute from './components/PrivateRoute';
import AuthPage from './pages/AuthPage';
import Layout from './components/Layout';
import Home from './pages/Home';
import ForgotPassword from './pages/ForgotPassword';
import Profile from './pages/Profile';
import RideHistory from './pages/RideHistory';
import RequestRide from './pages/RequestRide';
import OfferRide from './pages/OfferRide';
import PushNotifications from './components/PushNotifications';
import DemoPage from './pages/DemoPage';

function App() {
  const [darkMode, setDarkMode] = useState(false);

  const toggleDarkMode = () => {
    setDarkMode(!darkMode);
  };

  return (
    <ThemeProvider theme={darkMode ? darkTheme : lightTheme}>
      <CssBaseline />
      <AuthProvider>
        <NotificationsProvider>
          <Router>
            <Routes>
              <Route path="/auth" element={<AuthPage darkMode={darkMode} toggleDarkMode={toggleDarkMode} />} />
              <Route path="/forgot-password" element={<ForgotPassword darkMode={darkMode} toggleDarkMode={toggleDarkMode} />} />
              <Route path="/demo" element={<DemoPage darkMode={darkMode} toggleDarkMode={toggleDarkMode} />} />
              <Route element={<PrivateRoute />}>
                <Route element={<Layout darkMode={darkMode} toggleDarkMode={toggleDarkMode} />}>
                  <Route path="/" element={<Home />} />
                  <Route path="/profile" element={<Profile />} />
                  <Route path="/ride-history" element={<RideHistory />} />
                  <Route path="/request-ride" element={<RequestRide />} />
                  <Route path="/offer-ride" element={<OfferRide />} />
                </Route>
              </Route>
              <Route path="*" element={<Navigate to="/auth" />} />
            </Routes>
            <PushNotifications />
          </Router>
        </NotificationsProvider>
      </AuthProvider>
    </ThemeProvider>
  );
}

export default App;

================
File: src/AppContent.js
================
import React, { useContext } from 'react';
import { Route, Routes, Navigate } from 'react-router-dom';
import { AuthContext } from './contexts/AuthContext';
import Navbar from './components/Navbar';
import Home from './pages/Home';
import Login from './pages/Login';
import Signup from './pages/Signup';
import Profile from './pages/Profile';
import RideHistory from './pages/RideHistory';
import RequestRide from './pages/RequestRide';
import OfferRide from './pages/OfferRide';

function AuthenticatedApp() {
  return (
    <>
      <Navbar />
      <Routes>
        <Route path="/" element={<Home />} />
        <Route path="/profile" element={<Profile />} />
        <Route path="/ride-history" element={<RideHistory />} />
        <Route path="/request-ride" element={<RequestRide />} />
        <Route path="/offer-ride" element={<OfferRide />} />
        <Route path="*" element={<Navigate to="/" />} />
      </Routes>
    </>
  );
}

function UnauthenticatedApp() {
  return (
    <Routes>
      <Route path="/login" element={<Login />} />
      <Route path="/signup" element={<Signup />} />
      <Route path="*" element={<Navigate to="/login" />} />
    </Routes>
  );
}

function AppContent() {
  const { currentUser, loading } = useContext(AuthContext);

  if (loading) {
    return <div>Loading...</div>;
  }

  return currentUser ? <AuthenticatedApp /> : <UnauthenticatedApp />;
}

export default AppContent;

================
File: src/firebase.js
================
import { initializeApp } from 'firebase/app';
import { getAuth, createUserWithEmailAndPassword, signInAnonymously as firebaseSignInAnonymously, signInWithEmailAndPassword } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs, addDoc, serverTimestamp, orderBy } from 'firebase/firestore';
import { getMessaging, getToken, onMessage } from 'firebase/messaging';
const firebaseConfig = {
  apiKey: "AIzaSyCkqh6ZSNvY9hHNOuExDcwWGGjmRvXQ3J4",
  authDomain: "zwisch-gemini.firebaseapp.com",
  projectId: "zwisch-gemini",
  storageBucket: "zwisch-gemini.appspot.com",
  messagingSenderId: "75220160584",
  appId: "1:75220160584:web:ec7f54cd07a8655659887d"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const messaging = getMessaging(app);

export const signInAnonymously = () => {
  return firebaseSignInAnonymously(auth);
};

export const signUp = async (email, password, name, userType, childEmail = null) => {
  try {
    const { user } = await createUserWithEmailAndPassword(auth, email, password);
    await setDoc(doc(db, 'users', user.uid), {
      name,
      email,
      userType,
      childEmail: userType === 'parent' ? childEmail : null,
      createdAt: serverTimestamp(),
    });
    return user;
  } catch (error) {
    console.error('Error during sign up:', error);
    throw error;
  }
};

export const signIn = async (email, password) => {
  try {
    const { user } = await signInWithEmailAndPassword(auth, email, password);
    return user;
  } catch (error) {
    console.error('Error during sign in:', error);
    throw error;
  }
};

export const checkUserExists = async (email) => {
  try {
    const q = query(collection(db, 'users'), where('email', '==', email));
    const querySnapshot = await getDocs(q);
    return !querySnapshot.empty;
  } catch (error) {
    console.error('Error checking user existence:', error);
    throw error;
  }
};

export const getUserData = async (userId) => {
  try {
    const userDoc = await getDoc(doc(db, 'users', userId));
    if (userDoc.exists()) {
      return userDoc.data();
    } else {
      throw new Error('User not found');
    }
  } catch (error) {
    console.error('Error getting user data:', error);
    throw error;
  }
};

export const requestNotificationPermission = async (userId) => {
  try {
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      const token = await getToken(messaging, { vapidKey: process.env.REACT_APP_FIREBASE_VAPID_KEY });
      await setDoc(doc(db, 'users', userId), { fcmToken: token }, { merge: true });
      return token;
    } else {
      throw new Error('Notification permission denied');
    }
  } catch (error) {
    console.error('Error requesting notification permission:', error);
    throw error;
  }
};

export const onMessageListener = () => {
  return new Promise((resolve) => {
    onMessage(messaging, (payload) => {
      resolve(payload);
    });
  });
};

export { auth, db, serverTimestamp, collection, addDoc, query, where, getDocs, orderBy, doc, setDoc, getDoc };

================
File: src/index.css
================
body {
  margin: 0;
  font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen',
    'Ubuntu', 'Cantarell', 'Fira Sans', 'Droid Sans', 'Helvetica Neue',
    sans-serif;
  -webkit-font-smoothing: antialiased;
  -moz-osx-font-smoothing: grayscale;
}

code {
  font-family: source-code-pro, Menlo, Monaco, Consolas, 'Courier New',
    monospace;
}

================
File: src/index.js
================
import React from 'react';
import ReactDOM from 'react-dom/client';
import './index.css';
import App from './App';
import reportWebVitals from './reportWebVitals';
import { initializeApp } from 'firebase/app';

const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID
};

initializeApp(firebaseConfig);

const root = ReactDOM.createRoot(document.getElementById('root'));
root.render(
  <React.StrictMode>
    <App />
  </React.StrictMode>
);

reportWebVitals();

================
File: src/logo.svg
================
<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 841.9 595.3"><g fill="#61DAFB"><path d="M666.3 296.5c0-32.5-40.7-63.3-103.1-82.4 14.4-63.6 8-114.2-20.2-130.4-6.5-3.8-14.1-5.6-22.4-5.6v22.3c4.6 0 8.3.9 11.4 2.6 13.6 7.8 19.5 37.5 14.9 75.7-1.1 9.4-2.9 19.3-5.1 29.4-19.6-4.8-41-8.5-63.5-10.9-13.5-18.5-27.5-35.3-41.6-50 32.6-30.3 63.2-46.9 84-46.9V78c-27.5 0-63.5 19.6-99.9 53.6-36.4-33.8-72.4-53.2-99.9-53.2v22.3c20.7 0 51.4 16.5 84 46.6-14 14.7-28 31.4-41.3 49.9-22.6 2.4-44 6.1-63.6 11-2.3-10-4-19.7-5.2-29-4.7-38.2 1.1-67.9 14.6-75.8 3-1.8 6.9-2.6 11.5-2.6V78.5c-8.4 0-16 1.8-22.6 5.6-28.1 16.2-34.4 66.7-19.9 130.1-62.2 19.2-102.7 49.9-102.7 82.3 0 32.5 40.7 63.3 103.1 82.4-14.4 63.6-8 114.2 20.2 130.4 6.5 3.8 14.1 5.6 22.5 5.6 27.5 0 63.5-19.6 99.9-53.6 36.4 33.8 72.4 53.2 99.9 53.2 8.4 0 16-1.8 22.6-5.6 28.1-16.2 34.4-66.7 19.9-130.1 62-19.1 102.5-49.9 102.5-82.3zm-130.2-66.7c-3.7 12.9-8.3 26.2-13.5 39.5-4.1-8-8.4-16-13.1-24-4.6-8-9.5-15.8-14.4-23.4 14.2 2.1 27.9 4.7 41 7.9zm-45.8 106.5c-7.8 13.5-15.8 26.3-24.1 38.2-14.9 1.3-30 2-45.2 2-15.1 0-30.2-.7-45-1.9-8.3-11.9-16.4-24.6-24.2-38-7.6-13.1-14.5-26.4-20.8-39.8 6.2-13.4 13.2-26.8 20.7-39.9 7.8-13.5 15.8-26.3 24.1-38.2 14.9-1.3 30-2 45.2-2 15.1 0 30.2.7 45 1.9 8.3 11.9 16.4 24.6 24.2 38 7.6 13.1 14.5 26.4 20.8 39.8-6.3 13.4-13.2 26.8-20.7 39.9zm32.3-13c5.4 13.4 10 26.8 13.8 39.8-13.1 3.2-26.9 5.9-41.2 8 4.9-7.7 9.8-15.6 14.4-23.7 4.6-8 8.9-16.1 13-24.1zM421.2 430c-9.3-9.6-18.6-20.3-27.8-32 9 .4 18.2.7 27.5.7 9.4 0 18.7-.2 27.8-.7-9 11.7-18.3 22.4-27.5 32zm-74.4-58.9c-14.2-2.1-27.9-4.7-41-7.9 3.7-12.9 8.3-26.2 13.5-39.5 4.1 8 8.4 16 13.1 24 4.7 8 9.5 15.8 14.4 23.4zM420.7 163c9.3 9.6 18.6 20.3 27.8 32-9-.4-18.2-.7-27.5-.7-9.4 0-18.7.2-27.8.7 9-11.7 18.3-22.4 27.5-32zm-74 58.9c-4.9 7.7-9.8 15.6-14.4 23.7-4.6 8-8.9 16-13 24-5.4-13.4-10-26.8-13.8-39.8 13.1-3.1 26.9-5.8 41.2-7.9zm-90.5 125.2c-35.4-15.1-58.3-34.9-58.3-50.6 0-15.7 22.9-35.6 58.3-50.6 8.6-3.7 18-7 27.7-10.1 5.7 19.6 13.2 40 22.5 60.9-9.2 20.8-16.6 41.1-22.2 60.6-9.9-3.1-19.3-6.5-28-10.2zM310 490c-13.6-7.8-19.5-37.5-14.9-75.7 1.1-9.4 2.9-19.3 5.1-29.4 19.6 4.8 41 8.5 63.5 10.9 13.5 18.5 27.5 35.3 41.6 50-32.6 30.3-63.2 46.9-84 46.9-4.5-.1-8.3-1-11.3-2.7zm237.2-76.2c4.7 38.2-1.1 67.9-14.6 75.8-3 1.8-6.9 2.6-11.5 2.6-20.7 0-51.4-16.5-84-46.6 14-14.7 28-31.4 41.3-49.9 22.6-2.4 44-6.1 63.6-11 2.3 10.1 4.1 19.8 5.2 29.1zm38.5-66.7c-8.6 3.7-18 7-27.7 10.1-5.7-19.6-13.2-40-22.5-60.9 9.2-20.8 16.6-41.1 22.2-60.6 9.9 3.1 19.3 6.5 28.1 10.2 35.4 15.1 58.3 34.9 58.3 50.6-.1 15.7-23 35.6-58.4 50.6zM320.8 78.4z"/><circle cx="420.9" cy="296.5" r="45.7"/><path d="M520.5 78.1z"/></g></svg>

================
File: src/reportWebVitals.js
================
const reportWebVitals = onPerfEntry => {
  if (onPerfEntry && onPerfEntry instanceof Function) {
    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {
      getCLS(onPerfEntry);
      getFID(onPerfEntry);
      getFCP(onPerfEntry);
      getLCP(onPerfEntry);
      getTTFB(onPerfEntry);
    });
  }
};

export default reportWebVitals;

================
File: src/theme.js
================
import { createTheme } from '@mui/material/styles';

const commonTheme = {
  typography: {
    fontFamily: '"Outfit", "Roboto", "Helvetica", "Arial", sans-serif',
    h4: {
      fontWeight: 700,
    },
    button: {
      textTransform: 'none',
      fontWeight: 600,
    },
  },
  shape: {
    borderRadius: 12,
  },
  components: {
    MuiButton: {
      styleOverrides: {
        root: {
          boxShadow: 'none',
          '&:hover': {
            boxShadow: '0px 2px 4px rgba(0, 0, 0, 0.2)',
          },
        },
      },
    },
    MuiPaper: {
      styleOverrides: {
        root: {
          boxShadow: '0px 4px 20px rgba(0, 0, 0, 0.5)',
        },
      },
    },
  },
};

export const lightTheme = createTheme({
  ...commonTheme,
  palette: {
    mode: 'light',
    primary: {
      main: '#58F5BB',
      contrastText: '#000000',
    },
    secondary: {
      main: '#4A4A4A',
    },
    background: {
      default: '#F5F5F5',
      paper: '#FFFFFF',
    },
    text: {
      primary: '#000000',
      secondary: '#4A4A4A',
    },
  },
});

export const darkTheme = createTheme({
  ...commonTheme,
  palette: {
    mode: 'dark',
    primary: {
      main: '#58F5BB',
      contrastText: '#000000',
    },
    secondary: {
      main: '#B0B0B0',
    },
    background: {
      default: '#121212',
      paper: '#1E1E1E',
    },
    text: {
      primary: '#FFFFFF',
      secondary: '#B0B0B0',
    },
  },
});

================
File: .firebaserc
================
{
  "projects": {
    "default": "zwisch-gemini"
  }
}

================
File: .gitignore
================
# See https://help.github.com/articles/ignoring-files/ for more about ignoring files.

# dependencies
/node_modules
/.pnp
.pnp.js

/functions/node_modules
/functions/package-lock.json

.firebase

.env
.env.local
.env.development.local
.env.test.local
.env.production.local
*.env

# testing
/coverage

# production
/build

# misc
.DS_Store
.env.local
.env.development.local
.env.test.local
.env.production.local

npm-debug.log*
yarn-debug.log*
yarn-error.log*

================
File: claude_old_firebase.txt
================
import { initializeApp } from 'firebase/app';
import { getAuth, createUserWithEmailAndPassword, signInWithEmailAndPassword } from 'firebase/auth';
import { getFirestore, doc, setDoc, getDoc, collection, query, where, getDocs } from 'firebase/firestore';
import { getMessaging, getToken, onMessage } from 'firebase/messaging';

/*
const firebaseConfig = {
  apiKey: process.env.REACT_APP_FIREBASE_API_KEY,
  authDomain: process.env.REACT_APP_FIREBASE_AUTH_DOMAIN,
  projectId: process.env.REACT_APP_FIREBASE_PROJECT_ID,
  storageBucket: process.env.REACT_APP_FIREBASE_STORAGE_BUCKET,
  messagingSenderId: process.env.REACT_APP_FIREBASE_MESSAGING_SENDER_ID,
  appId: process.env.REACT_APP_FIREBASE_APP_ID
};
*/

const firebaseConfig = {
  apiKey: "AIzaSyCkqh6ZSNvY9hHNOuExDcwWGGjmRvXQ3J4",
  authDomain: "zwisch-gemini.firebaseapp.com",
  projectId: "zwisch-gemini",
  storageBucket: "zwisch-gemini.appspot.com",
  messagingSenderId: "75220160584",
  appId: "1:75220160584:web:ec7f54cd07a8655659887d"
};

const app = initializeApp(firebaseConfig);
const auth = getAuth(app);
const db = getFirestore(app);
const messaging = getMessaging(app);

export const firestore = db;

export const signUp = async (email, password, name, userType, childEmail = null) => {
  try {
    const { user } = await createUserWithEmailAndPassword(auth, email, password);
    await setDoc(doc(db, 'users', user.uid), {
      name,
      email,
      userType,
      childEmail: userType === 'parent' ? childEmail : null,
      createdAt: new Date(),
    });
    return user;
  } catch (error) {
    console.error('Error during sign up:', error);
    throw error;
  }
};

export const signIn = async (email, password) => {
  try {
    const { user } = await signInWithEmailAndPassword(auth, email, password);
    return user;
  } catch (error) {
    console.error('Error during sign in:', error);
    throw error;
  }
};

export const checkUserExists = async (email) => {
  try {
    const q = query(collection(db, 'users'), where('email', '==', email));
    const querySnapshot = await getDocs(q);
    return !querySnapshot.empty;
  } catch (error) {
    console.error('Error checking user existence:', error);
    throw error;
  }
};

export const getUserData = async (userId) => {
  try {
    const userDoc = await getDoc(doc(db, 'users', userId));
    if (userDoc.exists()) {
      return userDoc.data();
    } else {
      throw new Error('User not found');
    }
  } catch (error) {
    console.error('Error getting user data:', error);
    throw error;
  }
};

export const requestNotificationPermission = async (userId) => {
  try {
    const permission = await Notification.requestPermission();
    if (permission === 'granted') {
      const token = await getToken(messaging, { vapidKey: process.env.REACT_APP_FIREBASE_VAPID_KEY });
      await setDoc(doc(db, 'users', userId), { fcmToken: token }, { merge: true });
      return token;
    } else {
      throw new Error('Notification permission denied');
    }
  } catch (error) {
    console.error('Error requesting notification permission:', error);
    throw error;
  }
};

export const onMessageListener = () => {
  return new Promise((resolve) => {
    onMessage(messaging, (payload) => {
      resolve(payload);
    });
  });
};

export { auth, db };

================
File: domain_setup.md
================
## How to Connect a Subdomain to Firebase Hosting (Domain Hosted with Squarespace)

This guide explains how to connect a subdomain (e.g., `app.zwisch.app`) to a Firebase Hosting site when your domain (`zwisch.app`) is managed by Squarespace.

**Prerequisites:**

* You have a Firebase project set up with Firebase Hosting.
* You have a custom domain (e.g., `zwisch.app`) registered with Squarespace.

**Step 1: Get Firebase Verification Records**

1.  **Go to Firebase Console:** Open your web browser and navigate to: [https://console.firebase.google.com/](https://console.firebase.google.com/)
2.  **Select Your Project:** Click on your Firebase project (the one you want to use for hosting).
3.  **Go to Hosting:** In the left-hand side menu, find the "Hosting" section and click on it.
4. **Navigate to Domains:**  Once in the Hosting section, click on "Domains".
5.  **Add Custom Domain:** Click on "Connect a custom domain". 
6.  **Enter Subdomain:**  Type in your desired subdomain, including the full stop and your domain name (e.g., `app.zwisch.app`). 
7.  **Copy Records:**  Firebase will display two DNS records: an **A record** and a **TXT record**. Copy these values - you'll need them in the next step.

**Step 2: Add DNS Records in Squarespace**

1. **Log In to Squarespace:** Log in to your Squarespace account.
2.  **Access Domain Settings:**
    *   Go to the website that's connected to the domain you want to use.
    *   Go to **Settings** -> **Domains**. 
    *   Select your domain (`zwisch.app`).
3.  **Find DNS Management:** Look for an "Advanced Settings" option (or similar) where you can manage DNS records directly. The exact location may vary depending on your Squarespace version.
4.  **Create Subdomain (If Necessary):** Some Squarespace versions require you to explicitly create the subdomain (`app` in this case) before you can add DNS records for it. Look for a section to create subdomains within your Squarespace DNS settings. 
5.  **Add DNS Records:**
    *   **Add A Record:** Enter the "A record" values you copied from Firebase. You'll likely have fields for "Host" (enter your subdomain `app` or `app.zwisch.app` - check what Squarespace requires) and "Value" (Firebase's IP addresses). 
    *   **Add TXT Record:**  Do the same for the "TXT record" provided by Firebase. Enter the values into the appropriate fields.
6.  **Save Changes:** Make sure to save the DNS changes in your Squarespace settings. 

**Step 3: Verify and Wait**

1. **Wait for Propagation:** It can take a while (up to 48 hours, but usually much faster) for DNS changes to take full effect across the internet.
2. **Verify in Firebase:** Go back to your Firebase console -> Hosting -> Domains and click on the "Verify" button next to your subdomain. If the DNS records have propagated, Firebase will successfully connect your subdomain.

**Troubleshooting:**

* **Typos:**  Double-check every DNS record for typos. A single wrong character will cause problems.
* **Browser Cache:** Clear your browser cache or use an incognito/private browsing window to see the latest changes.
* **Squarespace Support:** If you have trouble finding the right settings in Squarespace, contact their support team for assistance. 
* **Firebase Support:**  For any issues within Firebase, don't hesitate to contact their support as well.

This detailed guide should help your colleague set up the subdomain connection! If you run into any more questions, just ask!

================
File: firebase.json
================
{
  "firestore": {
    "rules": "firestore.rules",
    "indexes": "firestore.indexes.json"
  },
  "hosting": {
    "public": "build",
    "ignore": [
      "firebase.json",
      "**/.*",
      "**/node_modules/**"
    ],
    "rewrites": [
      {
        "source": "**",
        "destination": "/index.html"
      }
    ]
  },
  "functions": [
    {
      "source": "functions",
      "codebase": "default",
      "ignore": [
        "node_modules",
        ".git",
        "firebase-debug.log",
        "firebase-debug.*.log",
        "*.local"
      ],
      "predeploy": [
        "npm --prefix \"$RESOURCE_DIR\" run lint"
      ]
    }
  ]
}

================
File: firestore.indexes.json
================
{
  "indexes": [],
  "fieldOverrides": []
}

================
File: firestore.rules
================
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // This rule allows anyone with your Firestore database reference to view, edit,
    // and delete all data in your Firestore database. It is useful for getting
    // started, but it is configured to expire after 30 days because it
    // leaves your app open to attackers. At that time, all client
    // requests to your Firestore database will be denied.
    //
    // Make sure to write security rules for your app before that time, or else
    // all client requests to your Firestore database will be denied until you Update
    // your rules
    match /{document=**} {
      allow read, write: if request.time < timestamp.date(2024, 9, 9);
    }
  }
}

================
File: package.json
================
{
  "name": "zwisch",
  "version": "0.1.0",
  "private": true,
  "dependencies": {
    "@apollo/client": "^3.11.4",
    "@emotion/react": "^11.13.0",
    "@emotion/styled": "^11.13.0",
    "@google/generative-ai": "^0.16.0",
    "@mui/icons-material": "^5.16.7",
    "@mui/material": "^5.16.7",
    "@testing-library/jest-dom": "^5.17.0",
    "@testing-library/react": "^13.4.0",
    "@testing-library/user-event": "^13.5.0",
    "firebase": "^10.12.5",
    "graphql": "^16.9.0",
    "react": "^18.3.1",
    "react-dom": "^18.3.1",
    "react-router-dom": "^6.26.0",
    "react-scripts": "5.0.1",
    "web-vitals": "^2.1.4"
  },
  "scripts": {
    "start": "react-scripts start",
    "build": "react-scripts build",
    "test": "react-scripts test",
    "eject": "react-scripts eject"
  },
  "eslintConfig": {
    "extends": [
      "react-app",
      "react-app/jest"
    ]
  },
  "browserslist": {
    "production": [
      ">0.2%",
      "not dead",
      "not op_mini all"
    ],
    "development": [
      "last 1 chrome version",
      "last 1 firefox version",
      "last 1 safari version"
    ]
  },
  "devDependencies": {
    "@babel/plugin-proposal-private-property-in-object": "^7.21.11"
  }
}

================
File: README.md
================
# Zwisch
Making school carpools convenient and eco-friendly!
